Grammar:

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statement
Rule 3     statements -> statements statement
Rule 4     statement -> for_statement
Rule 5     statement -> while_statement
Rule 6     statement -> if_statement
Rule 7     statement -> PRINT print_values ;
Rule 8     statement -> PRINT ID ;
Rule 9     statement -> div_assign ;
Rule 10    statement -> mul_assign ;
Rule 11    statement -> sub_assign ;
Rule 12    statement -> add_assign ;
Rule 13    statement -> RETURN return_values ;
Rule 14    statement -> CONTINUE ;
Rule 15    statement -> BREAK ;
Rule 16    statement -> assign ;
Rule 17    if_statement -> if_statement ELSE statements  [precedence=right, level=4]
Rule 18    if_statement -> if_statement ELSE if_statement  [precedence=right, level=4]
Rule 19    if_statement -> IF ( relative ) { statement }
Rule 20    if_statement -> IF ( relative ) statement
Rule 21    while_statement -> WHILE ( relative ) statement
Rule 22    while_statement -> WHILE ( relative ) { statements }
Rule 23    for_statement -> FOR ID = expr : expr statement
Rule 24    for_statement -> FOR ID = expr : expr { statements }
Rule 25    assign -> ID = STRING
Rule 26    assign -> ID = expr
Rule 27    add_assign -> ID ADD_ASSIGN expr
Rule 28    sub_assign -> ID SUB_ASSIGN expr
Rule 29    mul_assign -> ID [ row ] = expr
Rule 30    mul_assign -> ID MUL_ASSIGN expr
Rule 31    div_assign -> ID DIV_ASSIGN expr
Rule 32    matrix -> EYE ( INTNUM )
Rule 33    matrix -> ONES ( INTNUM )
Rule 34    matrix -> ZEROS ( INTNUM )
Rule 35    matrix -> matrix2
Rule 36    matrix -> matrix1
Rule 37    matrix -> [ ]
Rule 38    matrix -> matrix '
Rule 39    matrix1 -> [ rows1 ]
Rule 40    rows1 -> row
Rule 41    rows1 -> rows1 ; row
Rule 42    matrix2 -> [ rows2 ]
Rule 43    rows2 -> [ row ]
Rule 44    rows2 -> rows2 , [ row ]
Rule 45    row -> INTNUM
Rule 46    row -> row , INTNUM
Rule 47    expr -> ID
Rule 48    expr -> ID '
Rule 49    expr -> FLOATNUM
Rule 50    expr -> INTNUM
Rule 51    expr -> matrix
Rule 52    expr -> ( expr )
Rule 53    expr -> expr DOT_DIV expr
Rule 54    expr -> expr / expr  [precedence=left, level=2]
Rule 55    expr -> expr DOT_MUL expr
Rule 56    expr -> expr * expr  [precedence=left, level=2]
Rule 57    expr -> expr DOT_SUB expr
Rule 58    expr -> expr - expr  [precedence=left, level=1]
Rule 59    expr -> expr DOT_ADD expr
Rule 60    expr -> expr + expr  [precedence=left, level=1]
Rule 61    expr -> - expr  [precedence=right, level=3]
Rule 62    relative -> expr NEQ expr
Rule 63    relative -> expr EQ expr
Rule 64    relative -> expr LTE expr
Rule 65    relative -> expr < expr
Rule 66    relative -> expr GTE expr
Rule 67    relative -> expr > expr
Rule 68    print_values -> print_value
Rule 69    print_values -> print_values , print_value
Rule 70    print_value -> ID
Rule 71    print_value -> STRING
Rule 72    return_values -> return_value
Rule 73    return_values -> return_values , return_value
Rule 74    return_value -> expr
Rule 75    return_value -> FLOATNUM
Rule 76    return_value -> ID
Rule 77    return_value -> STRING

Unused terminals:

    UMINUS

Terminals, with rules where they appear:

'                    : 38 48
(                    : 19 20 21 22 32 33 34 52
)                    : 19 20 21 22 32 33 34 52
*                    : 56
+                    : 60
,                    : 44 46 69 73
-                    : 58 61
/                    : 54
:                    : 23 24
;                    : 7 8 9 10 11 12 13 14 15 16 41
<                    : 65
=                    : 23 24 25 26 29
>                    : 67
ADD_ASSIGN           : 27
BREAK                : 15
CONTINUE             : 14
DIV_ASSIGN           : 31
DOT_ADD              : 59
DOT_DIV              : 53
DOT_MUL              : 55
DOT_SUB              : 57
ELSE                 : 17 18
EQ                   : 63
EYE                  : 32
FLOATNUM             : 49 75
FOR                  : 23 24
GTE                  : 66
ID                   : 8 23 24 25 26 27 28 29 30 31 47 48 70 76
IF                   : 19 20
INTNUM               : 32 33 34 45 46 50
LTE                  : 64
MUL_ASSIGN           : 30
NEQ                  : 62
ONES                 : 33
PRINT                : 7 8
RETURN               : 13
STRING               : 25 71 77
SUB_ASSIGN           : 28
UMINUS               : 
WHILE                : 21 22
ZEROS                : 34
[                    : 29 37 39 42 43 44
]                    : 29 37 39 42 43 44
error                : 
{                    : 19 22 24
}                    : 19 22 24

Nonterminals, with rules where they appear:

add_assign           : 12
assign               : 16
div_assign           : 9
expr                 : 23 23 24 24 26 27 28 29 30 31 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 62 62 63 63 64 64 65 65 66 66 67 67 74
for_statement        : 4
if_statement         : 6 17 18 18
matrix               : 38 51
matrix1              : 36
matrix2              : 35
mul_assign           : 10
print_value          : 68 69
print_values         : 7 69
program              : 0
relative             : 19 20 21 22
return_value         : 72 73
return_values        : 13 73
row                  : 29 40 41 43 44 46
rows1                : 39 41
rows2                : 42 44
statement            : 2 3 19 20 21 23
statements           : 1 3 17 22 24
sub_assign           : 11
while_statement      : 5


state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 1

    (0) S' -> program .


state 2

    (1) program -> statements .
    (3) statements -> statements . statement
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    $end            reduce using rule 1 (program -> statements .)
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    statement                      shift and go to state 20
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 3

    (2) statements -> statement .
    PRINT           reduce using rule 2 (statements -> statement .)
    RETURN          reduce using rule 2 (statements -> statement .)
    CONTINUE        reduce using rule 2 (statements -> statement .)
    BREAK           reduce using rule 2 (statements -> statement .)
    FOR             reduce using rule 2 (statements -> statement .)
    WHILE           reduce using rule 2 (statements -> statement .)
    IF              reduce using rule 2 (statements -> statement .)
    ID              reduce using rule 2 (statements -> statement .)
    $end            reduce using rule 2 (statements -> statement .)
    ELSE            reduce using rule 2 (statements -> statement .)
    }               reduce using rule 2 (statements -> statement .)


state 4

    (4) statement -> for_statement .
    PRINT           reduce using rule 4 (statement -> for_statement .)
    RETURN          reduce using rule 4 (statement -> for_statement .)
    CONTINUE        reduce using rule 4 (statement -> for_statement .)
    BREAK           reduce using rule 4 (statement -> for_statement .)
    FOR             reduce using rule 4 (statement -> for_statement .)
    WHILE           reduce using rule 4 (statement -> for_statement .)
    IF              reduce using rule 4 (statement -> for_statement .)
    ID              reduce using rule 4 (statement -> for_statement .)
    $end            reduce using rule 4 (statement -> for_statement .)
    ELSE            reduce using rule 4 (statement -> for_statement .)
    }               reduce using rule 4 (statement -> for_statement .)


state 5

    (5) statement -> while_statement .
    PRINT           reduce using rule 5 (statement -> while_statement .)
    RETURN          reduce using rule 5 (statement -> while_statement .)
    CONTINUE        reduce using rule 5 (statement -> while_statement .)
    BREAK           reduce using rule 5 (statement -> while_statement .)
    FOR             reduce using rule 5 (statement -> while_statement .)
    WHILE           reduce using rule 5 (statement -> while_statement .)
    IF              reduce using rule 5 (statement -> while_statement .)
    ID              reduce using rule 5 (statement -> while_statement .)
    $end            reduce using rule 5 (statement -> while_statement .)
    ELSE            reduce using rule 5 (statement -> while_statement .)
    }               reduce using rule 5 (statement -> while_statement .)


state 6

    (6) statement -> if_statement .
    (17) if_statement -> if_statement . ELSE statements
    (18) if_statement -> if_statement . ELSE if_statement
  ! shift/reduce conflict for ELSE resolved as shift
    PRINT           reduce using rule 6 (statement -> if_statement .)
    RETURN          reduce using rule 6 (statement -> if_statement .)
    CONTINUE        reduce using rule 6 (statement -> if_statement .)
    BREAK           reduce using rule 6 (statement -> if_statement .)
    FOR             reduce using rule 6 (statement -> if_statement .)
    WHILE           reduce using rule 6 (statement -> if_statement .)
    IF              reduce using rule 6 (statement -> if_statement .)
    ID              reduce using rule 6 (statement -> if_statement .)
    $end            reduce using rule 6 (statement -> if_statement .)
    }               reduce using rule 6 (statement -> if_statement .)
    ELSE            shift and go to state 21


state 7

    (7) statement -> PRINT . print_values ;
    (8) statement -> PRINT . ID ;
    (68) print_values -> . print_value
    (69) print_values -> . print_values , print_value
    (70) print_value -> . ID
    (71) print_value -> . STRING
    ID              shift and go to state 23
    STRING          shift and go to state 25

    print_values                   shift and go to state 22
    print_value                    shift and go to state 24

state 8

    (31) div_assign -> ID . DIV_ASSIGN expr
    (29) mul_assign -> ID . [ row ] = expr
    (30) mul_assign -> ID . MUL_ASSIGN expr
    (28) sub_assign -> ID . SUB_ASSIGN expr
    (27) add_assign -> ID . ADD_ASSIGN expr
    (25) assign -> ID . = STRING
    (26) assign -> ID . = expr
    DIV_ASSIGN      shift and go to state 26
    [               shift and go to state 27
    MUL_ASSIGN      shift and go to state 29
    SUB_ASSIGN      shift and go to state 30
    ADD_ASSIGN      shift and go to state 31
    =               shift and go to state 28


state 9

    (9) statement -> div_assign . ;
    ;               shift and go to state 32


state 10

    (10) statement -> mul_assign . ;
    ;               shift and go to state 33


state 11

    (11) statement -> sub_assign . ;
    ;               shift and go to state 34


state 12

    (12) statement -> add_assign . ;
    ;               shift and go to state 35


state 13

    (13) statement -> RETURN . return_values ;
    (72) return_values -> . return_value
    (73) return_values -> . return_values , return_value
    (74) return_value -> . expr
    (75) return_value -> . FLOATNUM
    (76) return_value -> . ID
    (77) return_value -> . STRING
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    STRING          shift and go to state 41
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    return_values                  shift and go to state 36
    return_value                   shift and go to state 37
    expr                           shift and go to state 38
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 14

    (14) statement -> CONTINUE . ;
    ;               shift and go to state 52


state 15

    (15) statement -> BREAK . ;
    ;               shift and go to state 53


state 16

    (16) statement -> assign . ;
    ;               shift and go to state 54


state 17

    (23) for_statement -> FOR . ID = expr : expr statement
    (24) for_statement -> FOR . ID = expr : expr { statements }
    ID              shift and go to state 55


state 18

    (21) while_statement -> WHILE . ( relative ) statement
    (22) while_statement -> WHILE . ( relative ) { statements }
    (               shift and go to state 56


state 19

    (19) if_statement -> IF . ( relative ) { statement }
    (20) if_statement -> IF . ( relative ) statement
    (               shift and go to state 57


state 20

    (3) statements -> statements statement .
    PRINT           reduce using rule 3 (statements -> statements statement .)
    RETURN          reduce using rule 3 (statements -> statements statement .)
    CONTINUE        reduce using rule 3 (statements -> statements statement .)
    BREAK           reduce using rule 3 (statements -> statements statement .)
    FOR             reduce using rule 3 (statements -> statements statement .)
    WHILE           reduce using rule 3 (statements -> statements statement .)
    IF              reduce using rule 3 (statements -> statements statement .)
    ID              reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)
    ELSE            reduce using rule 3 (statements -> statements statement .)
    }               reduce using rule 3 (statements -> statements statement .)


state 21

    (17) if_statement -> if_statement ELSE . statements
    (18) if_statement -> if_statement ELSE . if_statement
    (2) statements -> . statement
    (3) statements -> . statements statement
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    IF              shift and go to state 19
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    ID              shift and go to state 8

    if_statement                   shift and go to state 58
    statements                     shift and go to state 59
    statement                      shift and go to state 3
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 22

    (7) statement -> PRINT print_values . ;
    (69) print_values -> print_values . , print_value
    ;               shift and go to state 60
    ,               shift and go to state 61


state 23

    (8) statement -> PRINT ID . ;
    (70) print_value -> ID .
  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 62
    ,               reduce using rule 70 (print_value -> ID .)


state 24

    (68) print_values -> print_value .
    ;               reduce using rule 68 (print_values -> print_value .)
    ,               reduce using rule 68 (print_values -> print_value .)


state 25

    (71) print_value -> STRING .
    ;               reduce using rule 71 (print_value -> STRING .)
    ,               reduce using rule 71 (print_value -> STRING .)


state 26

    (31) div_assign -> ID DIV_ASSIGN . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 64
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 27

    (29) mul_assign -> ID [ . row ] = expr
    (45) row -> . INTNUM
    (46) row -> . row , INTNUM
    INTNUM          shift and go to state 67

    row                            shift and go to state 66

state 28

    (25) assign -> ID = . STRING
    (26) assign -> ID = . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    STRING          shift and go to state 68
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 69
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 29

    (30) mul_assign -> ID MUL_ASSIGN . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 70
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 30

    (28) sub_assign -> ID SUB_ASSIGN . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 71
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 31

    (27) add_assign -> ID ADD_ASSIGN . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 72
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 32

    (9) statement -> div_assign ; .
    PRINT           reduce using rule 9 (statement -> div_assign ; .)
    RETURN          reduce using rule 9 (statement -> div_assign ; .)
    CONTINUE        reduce using rule 9 (statement -> div_assign ; .)
    BREAK           reduce using rule 9 (statement -> div_assign ; .)
    FOR             reduce using rule 9 (statement -> div_assign ; .)
    WHILE           reduce using rule 9 (statement -> div_assign ; .)
    IF              reduce using rule 9 (statement -> div_assign ; .)
    ID              reduce using rule 9 (statement -> div_assign ; .)
    $end            reduce using rule 9 (statement -> div_assign ; .)
    ELSE            reduce using rule 9 (statement -> div_assign ; .)
    }               reduce using rule 9 (statement -> div_assign ; .)


state 33

    (10) statement -> mul_assign ; .
    PRINT           reduce using rule 10 (statement -> mul_assign ; .)
    RETURN          reduce using rule 10 (statement -> mul_assign ; .)
    CONTINUE        reduce using rule 10 (statement -> mul_assign ; .)
    BREAK           reduce using rule 10 (statement -> mul_assign ; .)
    FOR             reduce using rule 10 (statement -> mul_assign ; .)
    WHILE           reduce using rule 10 (statement -> mul_assign ; .)
    IF              reduce using rule 10 (statement -> mul_assign ; .)
    ID              reduce using rule 10 (statement -> mul_assign ; .)
    $end            reduce using rule 10 (statement -> mul_assign ; .)
    ELSE            reduce using rule 10 (statement -> mul_assign ; .)
    }               reduce using rule 10 (statement -> mul_assign ; .)


state 34

    (11) statement -> sub_assign ; .
    PRINT           reduce using rule 11 (statement -> sub_assign ; .)
    RETURN          reduce using rule 11 (statement -> sub_assign ; .)
    CONTINUE        reduce using rule 11 (statement -> sub_assign ; .)
    BREAK           reduce using rule 11 (statement -> sub_assign ; .)
    FOR             reduce using rule 11 (statement -> sub_assign ; .)
    WHILE           reduce using rule 11 (statement -> sub_assign ; .)
    IF              reduce using rule 11 (statement -> sub_assign ; .)
    ID              reduce using rule 11 (statement -> sub_assign ; .)
    $end            reduce using rule 11 (statement -> sub_assign ; .)
    ELSE            reduce using rule 11 (statement -> sub_assign ; .)
    }               reduce using rule 11 (statement -> sub_assign ; .)


state 35

    (12) statement -> add_assign ; .
    PRINT           reduce using rule 12 (statement -> add_assign ; .)
    RETURN          reduce using rule 12 (statement -> add_assign ; .)
    CONTINUE        reduce using rule 12 (statement -> add_assign ; .)
    BREAK           reduce using rule 12 (statement -> add_assign ; .)
    FOR             reduce using rule 12 (statement -> add_assign ; .)
    WHILE           reduce using rule 12 (statement -> add_assign ; .)
    IF              reduce using rule 12 (statement -> add_assign ; .)
    ID              reduce using rule 12 (statement -> add_assign ; .)
    $end            reduce using rule 12 (statement -> add_assign ; .)
    ELSE            reduce using rule 12 (statement -> add_assign ; .)
    }               reduce using rule 12 (statement -> add_assign ; .)


state 36

    (13) statement -> RETURN return_values . ;
    (73) return_values -> return_values . , return_value
    ;               shift and go to state 73
    ,               shift and go to state 74


state 37

    (72) return_values -> return_value .
    ;               reduce using rule 72 (return_values -> return_value .)
    ,               reduce using rule 72 (return_values -> return_value .)


state 38

    (74) return_value -> expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    ;               reduce using rule 74 (return_value -> expr .)
    ,               reduce using rule 74 (return_value -> expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 39

    (75) return_value -> FLOATNUM .
    (49) expr -> FLOATNUM .
  ! reduce/reduce conflict for ; resolved using rule 49 (expr -> FLOATNUM .)
  ! reduce/reduce conflict for , resolved using rule 49 (expr -> FLOATNUM .)
    DOT_DIV         reduce using rule 49 (expr -> FLOATNUM .)
    /               reduce using rule 49 (expr -> FLOATNUM .)
    DOT_MUL         reduce using rule 49 (expr -> FLOATNUM .)
    *               reduce using rule 49 (expr -> FLOATNUM .)
    DOT_SUB         reduce using rule 49 (expr -> FLOATNUM .)
    -               reduce using rule 49 (expr -> FLOATNUM .)
    DOT_ADD         reduce using rule 49 (expr -> FLOATNUM .)
    +               reduce using rule 49 (expr -> FLOATNUM .)
    ;               reduce using rule 49 (expr -> FLOATNUM .)
    ,               reduce using rule 49 (expr -> FLOATNUM .)


state 40

    (76) return_value -> ID .
    (47) expr -> ID .
    (48) expr -> ID . '
  ! reduce/reduce conflict for ; resolved using rule 47 (expr -> ID .)
  ! reduce/reduce conflict for , resolved using rule 47 (expr -> ID .)
    DOT_DIV         reduce using rule 47 (expr -> ID .)
    /               reduce using rule 47 (expr -> ID .)
    DOT_MUL         reduce using rule 47 (expr -> ID .)
    *               reduce using rule 47 (expr -> ID .)
    DOT_SUB         reduce using rule 47 (expr -> ID .)
    -               reduce using rule 47 (expr -> ID .)
    DOT_ADD         reduce using rule 47 (expr -> ID .)
    +               reduce using rule 47 (expr -> ID .)
    ;               reduce using rule 47 (expr -> ID .)
    ,               reduce using rule 47 (expr -> ID .)
    '               shift and go to state 83


state 41

    (77) return_value -> STRING .
    ;               reduce using rule 77 (return_value -> STRING .)
    ,               reduce using rule 77 (return_value -> STRING .)


state 42

    (50) expr -> INTNUM .
    DOT_DIV         reduce using rule 50 (expr -> INTNUM .)
    /               reduce using rule 50 (expr -> INTNUM .)
    DOT_MUL         reduce using rule 50 (expr -> INTNUM .)
    *               reduce using rule 50 (expr -> INTNUM .)
    DOT_SUB         reduce using rule 50 (expr -> INTNUM .)
    -               reduce using rule 50 (expr -> INTNUM .)
    DOT_ADD         reduce using rule 50 (expr -> INTNUM .)
    +               reduce using rule 50 (expr -> INTNUM .)
    ;               reduce using rule 50 (expr -> INTNUM .)
    ,               reduce using rule 50 (expr -> INTNUM .)
    )               reduce using rule 50 (expr -> INTNUM .)
    NEQ             reduce using rule 50 (expr -> INTNUM .)
    EQ              reduce using rule 50 (expr -> INTNUM .)
    LTE             reduce using rule 50 (expr -> INTNUM .)
    <               reduce using rule 50 (expr -> INTNUM .)
    GTE             reduce using rule 50 (expr -> INTNUM .)
    >               reduce using rule 50 (expr -> INTNUM .)
    :               reduce using rule 50 (expr -> INTNUM .)
    {               reduce using rule 50 (expr -> INTNUM .)
    PRINT           reduce using rule 50 (expr -> INTNUM .)
    RETURN          reduce using rule 50 (expr -> INTNUM .)
    CONTINUE        reduce using rule 50 (expr -> INTNUM .)
    BREAK           reduce using rule 50 (expr -> INTNUM .)
    FOR             reduce using rule 50 (expr -> INTNUM .)
    WHILE           reduce using rule 50 (expr -> INTNUM .)
    IF              reduce using rule 50 (expr -> INTNUM .)
    ID              reduce using rule 50 (expr -> INTNUM .)


state 43

    (51) expr -> matrix .
    (38) matrix -> matrix . '
    DOT_DIV         reduce using rule 51 (expr -> matrix .)
    /               reduce using rule 51 (expr -> matrix .)
    DOT_MUL         reduce using rule 51 (expr -> matrix .)
    *               reduce using rule 51 (expr -> matrix .)
    DOT_SUB         reduce using rule 51 (expr -> matrix .)
    -               reduce using rule 51 (expr -> matrix .)
    DOT_ADD         reduce using rule 51 (expr -> matrix .)
    +               reduce using rule 51 (expr -> matrix .)
    ;               reduce using rule 51 (expr -> matrix .)
    ,               reduce using rule 51 (expr -> matrix .)
    )               reduce using rule 51 (expr -> matrix .)
    NEQ             reduce using rule 51 (expr -> matrix .)
    EQ              reduce using rule 51 (expr -> matrix .)
    LTE             reduce using rule 51 (expr -> matrix .)
    <               reduce using rule 51 (expr -> matrix .)
    GTE             reduce using rule 51 (expr -> matrix .)
    >               reduce using rule 51 (expr -> matrix .)
    :               reduce using rule 51 (expr -> matrix .)
    {               reduce using rule 51 (expr -> matrix .)
    PRINT           reduce using rule 51 (expr -> matrix .)
    RETURN          reduce using rule 51 (expr -> matrix .)
    CONTINUE        reduce using rule 51 (expr -> matrix .)
    BREAK           reduce using rule 51 (expr -> matrix .)
    FOR             reduce using rule 51 (expr -> matrix .)
    WHILE           reduce using rule 51 (expr -> matrix .)
    IF              reduce using rule 51 (expr -> matrix .)
    ID              reduce using rule 51 (expr -> matrix .)
    '               shift and go to state 84


state 44

    (52) expr -> ( . expr )
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 85
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 45

    (61) expr -> - . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 86
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 46

    (32) matrix -> EYE . ( INTNUM )
    (               shift and go to state 87


state 47

    (33) matrix -> ONES . ( INTNUM )
    (               shift and go to state 88


state 48

    (34) matrix -> ZEROS . ( INTNUM )
    (               shift and go to state 89


state 49

    (35) matrix -> matrix2 .
    '               reduce using rule 35 (matrix -> matrix2 .)
    DOT_DIV         reduce using rule 35 (matrix -> matrix2 .)
    /               reduce using rule 35 (matrix -> matrix2 .)
    DOT_MUL         reduce using rule 35 (matrix -> matrix2 .)
    *               reduce using rule 35 (matrix -> matrix2 .)
    DOT_SUB         reduce using rule 35 (matrix -> matrix2 .)
    -               reduce using rule 35 (matrix -> matrix2 .)
    DOT_ADD         reduce using rule 35 (matrix -> matrix2 .)
    +               reduce using rule 35 (matrix -> matrix2 .)
    ;               reduce using rule 35 (matrix -> matrix2 .)
    ,               reduce using rule 35 (matrix -> matrix2 .)
    )               reduce using rule 35 (matrix -> matrix2 .)
    NEQ             reduce using rule 35 (matrix -> matrix2 .)
    EQ              reduce using rule 35 (matrix -> matrix2 .)
    LTE             reduce using rule 35 (matrix -> matrix2 .)
    <               reduce using rule 35 (matrix -> matrix2 .)
    GTE             reduce using rule 35 (matrix -> matrix2 .)
    >               reduce using rule 35 (matrix -> matrix2 .)
    :               reduce using rule 35 (matrix -> matrix2 .)
    {               reduce using rule 35 (matrix -> matrix2 .)
    PRINT           reduce using rule 35 (matrix -> matrix2 .)
    RETURN          reduce using rule 35 (matrix -> matrix2 .)
    CONTINUE        reduce using rule 35 (matrix -> matrix2 .)
    BREAK           reduce using rule 35 (matrix -> matrix2 .)
    FOR             reduce using rule 35 (matrix -> matrix2 .)
    WHILE           reduce using rule 35 (matrix -> matrix2 .)
    IF              reduce using rule 35 (matrix -> matrix2 .)
    ID              reduce using rule 35 (matrix -> matrix2 .)


state 50

    (36) matrix -> matrix1 .
    '               reduce using rule 36 (matrix -> matrix1 .)
    DOT_DIV         reduce using rule 36 (matrix -> matrix1 .)
    /               reduce using rule 36 (matrix -> matrix1 .)
    DOT_MUL         reduce using rule 36 (matrix -> matrix1 .)
    *               reduce using rule 36 (matrix -> matrix1 .)
    DOT_SUB         reduce using rule 36 (matrix -> matrix1 .)
    -               reduce using rule 36 (matrix -> matrix1 .)
    DOT_ADD         reduce using rule 36 (matrix -> matrix1 .)
    +               reduce using rule 36 (matrix -> matrix1 .)
    ;               reduce using rule 36 (matrix -> matrix1 .)
    ,               reduce using rule 36 (matrix -> matrix1 .)
    )               reduce using rule 36 (matrix -> matrix1 .)
    NEQ             reduce using rule 36 (matrix -> matrix1 .)
    EQ              reduce using rule 36 (matrix -> matrix1 .)
    LTE             reduce using rule 36 (matrix -> matrix1 .)
    <               reduce using rule 36 (matrix -> matrix1 .)
    GTE             reduce using rule 36 (matrix -> matrix1 .)
    >               reduce using rule 36 (matrix -> matrix1 .)
    :               reduce using rule 36 (matrix -> matrix1 .)
    {               reduce using rule 36 (matrix -> matrix1 .)
    PRINT           reduce using rule 36 (matrix -> matrix1 .)
    RETURN          reduce using rule 36 (matrix -> matrix1 .)
    CONTINUE        reduce using rule 36 (matrix -> matrix1 .)
    BREAK           reduce using rule 36 (matrix -> matrix1 .)
    FOR             reduce using rule 36 (matrix -> matrix1 .)
    WHILE           reduce using rule 36 (matrix -> matrix1 .)
    IF              reduce using rule 36 (matrix -> matrix1 .)
    ID              reduce using rule 36 (matrix -> matrix1 .)


state 51

    (37) matrix -> [ . ]
    (42) matrix2 -> [ . rows2 ]
    (39) matrix1 -> [ . rows1 ]
    (43) rows2 -> . [ row ]
    (44) rows2 -> . rows2 , [ row ]
    (40) rows1 -> . row
    (41) rows1 -> . rows1 ; row
    (45) row -> . INTNUM
    (46) row -> . row , INTNUM
    ]               shift and go to state 91
    [               shift and go to state 90
    INTNUM          shift and go to state 67

    rows2                          shift and go to state 92
    rows1                          shift and go to state 93
    row                            shift and go to state 94

state 52

    (14) statement -> CONTINUE ; .
    PRINT           reduce using rule 14 (statement -> CONTINUE ; .)
    RETURN          reduce using rule 14 (statement -> CONTINUE ; .)
    CONTINUE        reduce using rule 14 (statement -> CONTINUE ; .)
    BREAK           reduce using rule 14 (statement -> CONTINUE ; .)
    FOR             reduce using rule 14 (statement -> CONTINUE ; .)
    WHILE           reduce using rule 14 (statement -> CONTINUE ; .)
    IF              reduce using rule 14 (statement -> CONTINUE ; .)
    ID              reduce using rule 14 (statement -> CONTINUE ; .)
    $end            reduce using rule 14 (statement -> CONTINUE ; .)
    ELSE            reduce using rule 14 (statement -> CONTINUE ; .)
    }               reduce using rule 14 (statement -> CONTINUE ; .)


state 53

    (15) statement -> BREAK ; .
    PRINT           reduce using rule 15 (statement -> BREAK ; .)
    RETURN          reduce using rule 15 (statement -> BREAK ; .)
    CONTINUE        reduce using rule 15 (statement -> BREAK ; .)
    BREAK           reduce using rule 15 (statement -> BREAK ; .)
    FOR             reduce using rule 15 (statement -> BREAK ; .)
    WHILE           reduce using rule 15 (statement -> BREAK ; .)
    IF              reduce using rule 15 (statement -> BREAK ; .)
    ID              reduce using rule 15 (statement -> BREAK ; .)
    $end            reduce using rule 15 (statement -> BREAK ; .)
    ELSE            reduce using rule 15 (statement -> BREAK ; .)
    }               reduce using rule 15 (statement -> BREAK ; .)


state 54

    (16) statement -> assign ; .
    PRINT           reduce using rule 16 (statement -> assign ; .)
    RETURN          reduce using rule 16 (statement -> assign ; .)
    CONTINUE        reduce using rule 16 (statement -> assign ; .)
    BREAK           reduce using rule 16 (statement -> assign ; .)
    FOR             reduce using rule 16 (statement -> assign ; .)
    WHILE           reduce using rule 16 (statement -> assign ; .)
    IF              reduce using rule 16 (statement -> assign ; .)
    ID              reduce using rule 16 (statement -> assign ; .)
    $end            reduce using rule 16 (statement -> assign ; .)
    ELSE            reduce using rule 16 (statement -> assign ; .)
    }               reduce using rule 16 (statement -> assign ; .)


state 55

    (23) for_statement -> FOR ID . = expr : expr statement
    (24) for_statement -> FOR ID . = expr : expr { statements }
    =               shift and go to state 95


state 56

    (21) while_statement -> WHILE ( . relative ) statement
    (22) while_statement -> WHILE ( . relative ) { statements }
    (62) relative -> . expr NEQ expr
    (63) relative -> . expr EQ expr
    (64) relative -> . expr LTE expr
    (65) relative -> . expr < expr
    (66) relative -> . expr GTE expr
    (67) relative -> . expr > expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    relative                       shift and go to state 96
    expr                           shift and go to state 97
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 57

    (19) if_statement -> IF ( . relative ) { statement }
    (20) if_statement -> IF ( . relative ) statement
    (62) relative -> . expr NEQ expr
    (63) relative -> . expr EQ expr
    (64) relative -> . expr LTE expr
    (65) relative -> . expr < expr
    (66) relative -> . expr GTE expr
    (67) relative -> . expr > expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    relative                       shift and go to state 98
    expr                           shift and go to state 97
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 58

    (18) if_statement -> if_statement ELSE if_statement .
    (17) if_statement -> if_statement . ELSE statements
    (18) if_statement -> if_statement . ELSE if_statement
    (6) statement -> if_statement .
  ! reduce/reduce conflict for PRINT resolved using rule 6 (statement -> if_statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 6 (statement -> if_statement .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 6 (statement -> if_statement .)
  ! reduce/reduce conflict for BREAK resolved using rule 6 (statement -> if_statement .)
  ! reduce/reduce conflict for FOR resolved using rule 6 (statement -> if_statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 6 (statement -> if_statement .)
  ! reduce/reduce conflict for IF resolved using rule 6 (statement -> if_statement .)
  ! reduce/reduce conflict for ID resolved using rule 6 (statement -> if_statement .)
  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 6 (statement -> if_statement .)
  ! reduce/reduce conflict for } resolved using rule 6 (statement -> if_statement .)
    ELSE            shift and go to state 21
    PRINT           reduce using rule 6 (statement -> if_statement .)
    RETURN          reduce using rule 6 (statement -> if_statement .)
    CONTINUE        reduce using rule 6 (statement -> if_statement .)
    BREAK           reduce using rule 6 (statement -> if_statement .)
    FOR             reduce using rule 6 (statement -> if_statement .)
    WHILE           reduce using rule 6 (statement -> if_statement .)
    IF              reduce using rule 6 (statement -> if_statement .)
    ID              reduce using rule 6 (statement -> if_statement .)
    $end            reduce using rule 6 (statement -> if_statement .)
    }               reduce using rule 6 (statement -> if_statement .)


state 59

    (17) if_statement -> if_statement ELSE statements .
    (3) statements -> statements . statement
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    ELSE            reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    PRINT           reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    RETURN          reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    CONTINUE        reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    BREAK           reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    FOR             reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    WHILE           reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    IF              reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    ID              reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    $end            reduce using rule 17 (if_statement -> if_statement ELSE statements .)
    }               reduce using rule 17 (if_statement -> if_statement ELSE statements .)

    if_statement                   shift and go to state 6
    statement                      shift and go to state 20
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 60

    (7) statement -> PRINT print_values ; .
    PRINT           reduce using rule 7 (statement -> PRINT print_values ; .)
    RETURN          reduce using rule 7 (statement -> PRINT print_values ; .)
    CONTINUE        reduce using rule 7 (statement -> PRINT print_values ; .)
    BREAK           reduce using rule 7 (statement -> PRINT print_values ; .)
    FOR             reduce using rule 7 (statement -> PRINT print_values ; .)
    WHILE           reduce using rule 7 (statement -> PRINT print_values ; .)
    IF              reduce using rule 7 (statement -> PRINT print_values ; .)
    ID              reduce using rule 7 (statement -> PRINT print_values ; .)
    $end            reduce using rule 7 (statement -> PRINT print_values ; .)
    ELSE            reduce using rule 7 (statement -> PRINT print_values ; .)
    }               reduce using rule 7 (statement -> PRINT print_values ; .)


state 61

    (69) print_values -> print_values , . print_value
    (70) print_value -> . ID
    (71) print_value -> . STRING
    ID              shift and go to state 100
    STRING          shift and go to state 25

    print_value                    shift and go to state 99

state 62

    (8) statement -> PRINT ID ; .
    PRINT           reduce using rule 8 (statement -> PRINT ID ; .)
    RETURN          reduce using rule 8 (statement -> PRINT ID ; .)
    CONTINUE        reduce using rule 8 (statement -> PRINT ID ; .)
    BREAK           reduce using rule 8 (statement -> PRINT ID ; .)
    FOR             reduce using rule 8 (statement -> PRINT ID ; .)
    WHILE           reduce using rule 8 (statement -> PRINT ID ; .)
    IF              reduce using rule 8 (statement -> PRINT ID ; .)
    ID              reduce using rule 8 (statement -> PRINT ID ; .)
    $end            reduce using rule 8 (statement -> PRINT ID ; .)
    ELSE            reduce using rule 8 (statement -> PRINT ID ; .)
    }               reduce using rule 8 (statement -> PRINT ID ; .)


state 63

    (47) expr -> ID .
    (48) expr -> ID . '
    DOT_DIV         reduce using rule 47 (expr -> ID .)
    /               reduce using rule 47 (expr -> ID .)
    DOT_MUL         reduce using rule 47 (expr -> ID .)
    *               reduce using rule 47 (expr -> ID .)
    DOT_SUB         reduce using rule 47 (expr -> ID .)
    -               reduce using rule 47 (expr -> ID .)
    DOT_ADD         reduce using rule 47 (expr -> ID .)
    +               reduce using rule 47 (expr -> ID .)
    ;               reduce using rule 47 (expr -> ID .)
    )               reduce using rule 47 (expr -> ID .)
    ,               reduce using rule 47 (expr -> ID .)
    NEQ             reduce using rule 47 (expr -> ID .)
    EQ              reduce using rule 47 (expr -> ID .)
    LTE             reduce using rule 47 (expr -> ID .)
    <               reduce using rule 47 (expr -> ID .)
    GTE             reduce using rule 47 (expr -> ID .)
    >               reduce using rule 47 (expr -> ID .)
    :               reduce using rule 47 (expr -> ID .)
    {               reduce using rule 47 (expr -> ID .)
    PRINT           reduce using rule 47 (expr -> ID .)
    RETURN          reduce using rule 47 (expr -> ID .)
    CONTINUE        reduce using rule 47 (expr -> ID .)
    BREAK           reduce using rule 47 (expr -> ID .)
    FOR             reduce using rule 47 (expr -> ID .)
    WHILE           reduce using rule 47 (expr -> ID .)
    IF              reduce using rule 47 (expr -> ID .)
    ID              reduce using rule 47 (expr -> ID .)
    '               shift and go to state 83


state 64

    (31) div_assign -> ID DIV_ASSIGN expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    ;               reduce using rule 31 (div_assign -> ID DIV_ASSIGN expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 65

    (49) expr -> FLOATNUM .
    DOT_DIV         reduce using rule 49 (expr -> FLOATNUM .)
    /               reduce using rule 49 (expr -> FLOATNUM .)
    DOT_MUL         reduce using rule 49 (expr -> FLOATNUM .)
    *               reduce using rule 49 (expr -> FLOATNUM .)
    DOT_SUB         reduce using rule 49 (expr -> FLOATNUM .)
    -               reduce using rule 49 (expr -> FLOATNUM .)
    DOT_ADD         reduce using rule 49 (expr -> FLOATNUM .)
    +               reduce using rule 49 (expr -> FLOATNUM .)
    ;               reduce using rule 49 (expr -> FLOATNUM .)
    )               reduce using rule 49 (expr -> FLOATNUM .)
    ,               reduce using rule 49 (expr -> FLOATNUM .)
    NEQ             reduce using rule 49 (expr -> FLOATNUM .)
    EQ              reduce using rule 49 (expr -> FLOATNUM .)
    LTE             reduce using rule 49 (expr -> FLOATNUM .)
    <               reduce using rule 49 (expr -> FLOATNUM .)
    GTE             reduce using rule 49 (expr -> FLOATNUM .)
    >               reduce using rule 49 (expr -> FLOATNUM .)
    :               reduce using rule 49 (expr -> FLOATNUM .)
    {               reduce using rule 49 (expr -> FLOATNUM .)
    PRINT           reduce using rule 49 (expr -> FLOATNUM .)
    RETURN          reduce using rule 49 (expr -> FLOATNUM .)
    CONTINUE        reduce using rule 49 (expr -> FLOATNUM .)
    BREAK           reduce using rule 49 (expr -> FLOATNUM .)
    FOR             reduce using rule 49 (expr -> FLOATNUM .)
    WHILE           reduce using rule 49 (expr -> FLOATNUM .)
    IF              reduce using rule 49 (expr -> FLOATNUM .)
    ID              reduce using rule 49 (expr -> FLOATNUM .)


state 66

    (29) mul_assign -> ID [ row . ] = expr
    (46) row -> row . , INTNUM
    ]               shift and go to state 101
    ,               shift and go to state 102


state 67

    (45) row -> INTNUM .
    ]               reduce using rule 45 (row -> INTNUM .)
    ,               reduce using rule 45 (row -> INTNUM .)
    ;               reduce using rule 45 (row -> INTNUM .)


state 68

    (25) assign -> ID = STRING .
    ;               reduce using rule 25 (assign -> ID = STRING .)


state 69

    (26) assign -> ID = expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    ;               reduce using rule 26 (assign -> ID = expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 70

    (30) mul_assign -> ID MUL_ASSIGN expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    ;               reduce using rule 30 (mul_assign -> ID MUL_ASSIGN expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 71

    (28) sub_assign -> ID SUB_ASSIGN expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    ;               reduce using rule 28 (sub_assign -> ID SUB_ASSIGN expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 72

    (27) add_assign -> ID ADD_ASSIGN expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    ;               reduce using rule 27 (add_assign -> ID ADD_ASSIGN expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 73

    (13) statement -> RETURN return_values ; .
    PRINT           reduce using rule 13 (statement -> RETURN return_values ; .)
    RETURN          reduce using rule 13 (statement -> RETURN return_values ; .)
    CONTINUE        reduce using rule 13 (statement -> RETURN return_values ; .)
    BREAK           reduce using rule 13 (statement -> RETURN return_values ; .)
    FOR             reduce using rule 13 (statement -> RETURN return_values ; .)
    WHILE           reduce using rule 13 (statement -> RETURN return_values ; .)
    IF              reduce using rule 13 (statement -> RETURN return_values ; .)
    ID              reduce using rule 13 (statement -> RETURN return_values ; .)
    $end            reduce using rule 13 (statement -> RETURN return_values ; .)
    ELSE            reduce using rule 13 (statement -> RETURN return_values ; .)
    }               reduce using rule 13 (statement -> RETURN return_values ; .)


state 74

    (73) return_values -> return_values , . return_value
    (74) return_value -> . expr
    (75) return_value -> . FLOATNUM
    (76) return_value -> . ID
    (77) return_value -> . STRING
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    STRING          shift and go to state 41
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    return_value                   shift and go to state 103
    expr                           shift and go to state 38
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 75

    (53) expr -> expr DOT_DIV . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 104
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 76

    (54) expr -> expr / . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 105
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 77

    (55) expr -> expr DOT_MUL . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 106
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 78

    (56) expr -> expr * . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 107
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 79

    (57) expr -> expr DOT_SUB . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 108
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 80

    (58) expr -> expr - . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 109
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 81

    (59) expr -> expr DOT_ADD . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 110
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 82

    (60) expr -> expr + . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 111
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 83

    (48) expr -> ID ' .
    DOT_DIV         reduce using rule 48 (expr -> ID ' .)
    /               reduce using rule 48 (expr -> ID ' .)
    DOT_MUL         reduce using rule 48 (expr -> ID ' .)
    *               reduce using rule 48 (expr -> ID ' .)
    DOT_SUB         reduce using rule 48 (expr -> ID ' .)
    -               reduce using rule 48 (expr -> ID ' .)
    DOT_ADD         reduce using rule 48 (expr -> ID ' .)
    +               reduce using rule 48 (expr -> ID ' .)
    ;               reduce using rule 48 (expr -> ID ' .)
    ,               reduce using rule 48 (expr -> ID ' .)
    )               reduce using rule 48 (expr -> ID ' .)
    NEQ             reduce using rule 48 (expr -> ID ' .)
    EQ              reduce using rule 48 (expr -> ID ' .)
    LTE             reduce using rule 48 (expr -> ID ' .)
    <               reduce using rule 48 (expr -> ID ' .)
    GTE             reduce using rule 48 (expr -> ID ' .)
    >               reduce using rule 48 (expr -> ID ' .)
    :               reduce using rule 48 (expr -> ID ' .)
    {               reduce using rule 48 (expr -> ID ' .)
    PRINT           reduce using rule 48 (expr -> ID ' .)
    RETURN          reduce using rule 48 (expr -> ID ' .)
    CONTINUE        reduce using rule 48 (expr -> ID ' .)
    BREAK           reduce using rule 48 (expr -> ID ' .)
    FOR             reduce using rule 48 (expr -> ID ' .)
    WHILE           reduce using rule 48 (expr -> ID ' .)
    IF              reduce using rule 48 (expr -> ID ' .)
    ID              reduce using rule 48 (expr -> ID ' .)


state 84

    (38) matrix -> matrix ' .
    '               reduce using rule 38 (matrix -> matrix ' .)
    DOT_DIV         reduce using rule 38 (matrix -> matrix ' .)
    /               reduce using rule 38 (matrix -> matrix ' .)
    DOT_MUL         reduce using rule 38 (matrix -> matrix ' .)
    *               reduce using rule 38 (matrix -> matrix ' .)
    DOT_SUB         reduce using rule 38 (matrix -> matrix ' .)
    -               reduce using rule 38 (matrix -> matrix ' .)
    DOT_ADD         reduce using rule 38 (matrix -> matrix ' .)
    +               reduce using rule 38 (matrix -> matrix ' .)
    ;               reduce using rule 38 (matrix -> matrix ' .)
    ,               reduce using rule 38 (matrix -> matrix ' .)
    )               reduce using rule 38 (matrix -> matrix ' .)
    NEQ             reduce using rule 38 (matrix -> matrix ' .)
    EQ              reduce using rule 38 (matrix -> matrix ' .)
    LTE             reduce using rule 38 (matrix -> matrix ' .)
    <               reduce using rule 38 (matrix -> matrix ' .)
    GTE             reduce using rule 38 (matrix -> matrix ' .)
    >               reduce using rule 38 (matrix -> matrix ' .)
    :               reduce using rule 38 (matrix -> matrix ' .)
    {               reduce using rule 38 (matrix -> matrix ' .)
    PRINT           reduce using rule 38 (matrix -> matrix ' .)
    RETURN          reduce using rule 38 (matrix -> matrix ' .)
    CONTINUE        reduce using rule 38 (matrix -> matrix ' .)
    BREAK           reduce using rule 38 (matrix -> matrix ' .)
    FOR             reduce using rule 38 (matrix -> matrix ' .)
    WHILE           reduce using rule 38 (matrix -> matrix ' .)
    IF              reduce using rule 38 (matrix -> matrix ' .)
    ID              reduce using rule 38 (matrix -> matrix ' .)


state 85

    (52) expr -> ( expr . )
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    )               shift and go to state 112
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 86

    (61) expr -> - expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    DOT_DIV         reduce using rule 61 (expr -> - expr .)
    /               reduce using rule 61 (expr -> - expr .)
    DOT_MUL         reduce using rule 61 (expr -> - expr .)
    *               reduce using rule 61 (expr -> - expr .)
    DOT_SUB         reduce using rule 61 (expr -> - expr .)
    -               reduce using rule 61 (expr -> - expr .)
    DOT_ADD         reduce using rule 61 (expr -> - expr .)
    +               reduce using rule 61 (expr -> - expr .)
    ;               reduce using rule 61 (expr -> - expr .)
    ,               reduce using rule 61 (expr -> - expr .)
    )               reduce using rule 61 (expr -> - expr .)
    NEQ             reduce using rule 61 (expr -> - expr .)
    EQ              reduce using rule 61 (expr -> - expr .)
    LTE             reduce using rule 61 (expr -> - expr .)
    <               reduce using rule 61 (expr -> - expr .)
    GTE             reduce using rule 61 (expr -> - expr .)
    >               reduce using rule 61 (expr -> - expr .)
    :               reduce using rule 61 (expr -> - expr .)
    {               reduce using rule 61 (expr -> - expr .)
    PRINT           reduce using rule 61 (expr -> - expr .)
    RETURN          reduce using rule 61 (expr -> - expr .)
    CONTINUE        reduce using rule 61 (expr -> - expr .)
    BREAK           reduce using rule 61 (expr -> - expr .)
    FOR             reduce using rule 61 (expr -> - expr .)
    WHILE           reduce using rule 61 (expr -> - expr .)
    IF              reduce using rule 61 (expr -> - expr .)
    ID              reduce using rule 61 (expr -> - expr .)


state 87

    (32) matrix -> EYE ( . INTNUM )
    INTNUM          shift and go to state 113


state 88

    (33) matrix -> ONES ( . INTNUM )
    INTNUM          shift and go to state 114


state 89

    (34) matrix -> ZEROS ( . INTNUM )
    INTNUM          shift and go to state 115


state 90

    (43) rows2 -> [ . row ]
    (45) row -> . INTNUM
    (46) row -> . row , INTNUM
    INTNUM          shift and go to state 67

    row                            shift and go to state 116

state 91

    (37) matrix -> [ ] .
    '               reduce using rule 37 (matrix -> [ ] .)
    DOT_DIV         reduce using rule 37 (matrix -> [ ] .)
    /               reduce using rule 37 (matrix -> [ ] .)
    DOT_MUL         reduce using rule 37 (matrix -> [ ] .)
    *               reduce using rule 37 (matrix -> [ ] .)
    DOT_SUB         reduce using rule 37 (matrix -> [ ] .)
    -               reduce using rule 37 (matrix -> [ ] .)
    DOT_ADD         reduce using rule 37 (matrix -> [ ] .)
    +               reduce using rule 37 (matrix -> [ ] .)
    ;               reduce using rule 37 (matrix -> [ ] .)
    ,               reduce using rule 37 (matrix -> [ ] .)
    )               reduce using rule 37 (matrix -> [ ] .)
    NEQ             reduce using rule 37 (matrix -> [ ] .)
    EQ              reduce using rule 37 (matrix -> [ ] .)
    LTE             reduce using rule 37 (matrix -> [ ] .)
    <               reduce using rule 37 (matrix -> [ ] .)
    GTE             reduce using rule 37 (matrix -> [ ] .)
    >               reduce using rule 37 (matrix -> [ ] .)
    :               reduce using rule 37 (matrix -> [ ] .)
    {               reduce using rule 37 (matrix -> [ ] .)
    PRINT           reduce using rule 37 (matrix -> [ ] .)
    RETURN          reduce using rule 37 (matrix -> [ ] .)
    CONTINUE        reduce using rule 37 (matrix -> [ ] .)
    BREAK           reduce using rule 37 (matrix -> [ ] .)
    FOR             reduce using rule 37 (matrix -> [ ] .)
    WHILE           reduce using rule 37 (matrix -> [ ] .)
    IF              reduce using rule 37 (matrix -> [ ] .)
    ID              reduce using rule 37 (matrix -> [ ] .)


state 92

    (42) matrix2 -> [ rows2 . ]
    (44) rows2 -> rows2 . , [ row ]
    ]               shift and go to state 117
    ,               shift and go to state 118


state 93

    (39) matrix1 -> [ rows1 . ]
    (41) rows1 -> rows1 . ; row
    ]               shift and go to state 119
    ;               shift and go to state 120


state 94

    (40) rows1 -> row .
    (46) row -> row . , INTNUM
    ]               reduce using rule 40 (rows1 -> row .)
    ;               reduce using rule 40 (rows1 -> row .)
    ,               shift and go to state 102


state 95

    (23) for_statement -> FOR ID = . expr : expr statement
    (24) for_statement -> FOR ID = . expr : expr { statements }
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 121
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 96

    (21) while_statement -> WHILE ( relative . ) statement
    (22) while_statement -> WHILE ( relative . ) { statements }
    )               shift and go to state 122


state 97

    (62) relative -> expr . NEQ expr
    (63) relative -> expr . EQ expr
    (64) relative -> expr . LTE expr
    (65) relative -> expr . < expr
    (66) relative -> expr . GTE expr
    (67) relative -> expr . > expr
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    NEQ             shift and go to state 123
    EQ              shift and go to state 124
    LTE             shift and go to state 125
    <               shift and go to state 126
    GTE             shift and go to state 127
    >               shift and go to state 128
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 98

    (19) if_statement -> IF ( relative . ) { statement }
    (20) if_statement -> IF ( relative . ) statement
    )               shift and go to state 129


state 99

    (69) print_values -> print_values , print_value .
    ;               reduce using rule 69 (print_values -> print_values , print_value .)
    ,               reduce using rule 69 (print_values -> print_values , print_value .)


state 100

    (70) print_value -> ID .
    ;               reduce using rule 70 (print_value -> ID .)
    ,               reduce using rule 70 (print_value -> ID .)


state 101

    (29) mul_assign -> ID [ row ] . = expr
    =               shift and go to state 130


state 102

    (46) row -> row , . INTNUM
    INTNUM          shift and go to state 131


state 103

    (73) return_values -> return_values , return_value .
    ;               reduce using rule 73 (return_values -> return_values , return_value .)
    ,               reduce using rule 73 (return_values -> return_values , return_value .)


state 104

    (53) expr -> expr DOT_DIV expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
  ! shift/reduce conflict for DOT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for DOT_MUL resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for DOT_SUB resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for DOT_ADD resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ;               reduce using rule 53 (expr -> expr DOT_DIV expr .)
    ,               reduce using rule 53 (expr -> expr DOT_DIV expr .)
    )               reduce using rule 53 (expr -> expr DOT_DIV expr .)
    NEQ             reduce using rule 53 (expr -> expr DOT_DIV expr .)
    EQ              reduce using rule 53 (expr -> expr DOT_DIV expr .)
    LTE             reduce using rule 53 (expr -> expr DOT_DIV expr .)
    <               reduce using rule 53 (expr -> expr DOT_DIV expr .)
    GTE             reduce using rule 53 (expr -> expr DOT_DIV expr .)
    >               reduce using rule 53 (expr -> expr DOT_DIV expr .)
    :               reduce using rule 53 (expr -> expr DOT_DIV expr .)
    {               reduce using rule 53 (expr -> expr DOT_DIV expr .)
    PRINT           reduce using rule 53 (expr -> expr DOT_DIV expr .)
    RETURN          reduce using rule 53 (expr -> expr DOT_DIV expr .)
    CONTINUE        reduce using rule 53 (expr -> expr DOT_DIV expr .)
    BREAK           reduce using rule 53 (expr -> expr DOT_DIV expr .)
    FOR             reduce using rule 53 (expr -> expr DOT_DIV expr .)
    WHILE           reduce using rule 53 (expr -> expr DOT_DIV expr .)
    IF              reduce using rule 53 (expr -> expr DOT_DIV expr .)
    ID              reduce using rule 53 (expr -> expr DOT_DIV expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 105

    (54) expr -> expr / expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    DOT_DIV         reduce using rule 54 (expr -> expr / expr .)
    /               reduce using rule 54 (expr -> expr / expr .)
    DOT_MUL         reduce using rule 54 (expr -> expr / expr .)
    *               reduce using rule 54 (expr -> expr / expr .)
    DOT_SUB         reduce using rule 54 (expr -> expr / expr .)
    -               reduce using rule 54 (expr -> expr / expr .)
    DOT_ADD         reduce using rule 54 (expr -> expr / expr .)
    +               reduce using rule 54 (expr -> expr / expr .)
    ;               reduce using rule 54 (expr -> expr / expr .)
    ,               reduce using rule 54 (expr -> expr / expr .)
    )               reduce using rule 54 (expr -> expr / expr .)
    NEQ             reduce using rule 54 (expr -> expr / expr .)
    EQ              reduce using rule 54 (expr -> expr / expr .)
    LTE             reduce using rule 54 (expr -> expr / expr .)
    <               reduce using rule 54 (expr -> expr / expr .)
    GTE             reduce using rule 54 (expr -> expr / expr .)
    >               reduce using rule 54 (expr -> expr / expr .)
    :               reduce using rule 54 (expr -> expr / expr .)
    {               reduce using rule 54 (expr -> expr / expr .)
    PRINT           reduce using rule 54 (expr -> expr / expr .)
    RETURN          reduce using rule 54 (expr -> expr / expr .)
    CONTINUE        reduce using rule 54 (expr -> expr / expr .)
    BREAK           reduce using rule 54 (expr -> expr / expr .)
    FOR             reduce using rule 54 (expr -> expr / expr .)
    WHILE           reduce using rule 54 (expr -> expr / expr .)
    IF              reduce using rule 54 (expr -> expr / expr .)
    ID              reduce using rule 54 (expr -> expr / expr .)


state 106

    (55) expr -> expr DOT_MUL expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
  ! shift/reduce conflict for DOT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for DOT_MUL resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for DOT_SUB resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for DOT_ADD resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ;               reduce using rule 55 (expr -> expr DOT_MUL expr .)
    ,               reduce using rule 55 (expr -> expr DOT_MUL expr .)
    )               reduce using rule 55 (expr -> expr DOT_MUL expr .)
    NEQ             reduce using rule 55 (expr -> expr DOT_MUL expr .)
    EQ              reduce using rule 55 (expr -> expr DOT_MUL expr .)
    LTE             reduce using rule 55 (expr -> expr DOT_MUL expr .)
    <               reduce using rule 55 (expr -> expr DOT_MUL expr .)
    GTE             reduce using rule 55 (expr -> expr DOT_MUL expr .)
    >               reduce using rule 55 (expr -> expr DOT_MUL expr .)
    :               reduce using rule 55 (expr -> expr DOT_MUL expr .)
    {               reduce using rule 55 (expr -> expr DOT_MUL expr .)
    PRINT           reduce using rule 55 (expr -> expr DOT_MUL expr .)
    RETURN          reduce using rule 55 (expr -> expr DOT_MUL expr .)
    CONTINUE        reduce using rule 55 (expr -> expr DOT_MUL expr .)
    BREAK           reduce using rule 55 (expr -> expr DOT_MUL expr .)
    FOR             reduce using rule 55 (expr -> expr DOT_MUL expr .)
    WHILE           reduce using rule 55 (expr -> expr DOT_MUL expr .)
    IF              reduce using rule 55 (expr -> expr DOT_MUL expr .)
    ID              reduce using rule 55 (expr -> expr DOT_MUL expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 107

    (56) expr -> expr * expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    DOT_DIV         reduce using rule 56 (expr -> expr * expr .)
    /               reduce using rule 56 (expr -> expr * expr .)
    DOT_MUL         reduce using rule 56 (expr -> expr * expr .)
    *               reduce using rule 56 (expr -> expr * expr .)
    DOT_SUB         reduce using rule 56 (expr -> expr * expr .)
    -               reduce using rule 56 (expr -> expr * expr .)
    DOT_ADD         reduce using rule 56 (expr -> expr * expr .)
    +               reduce using rule 56 (expr -> expr * expr .)
    ;               reduce using rule 56 (expr -> expr * expr .)
    ,               reduce using rule 56 (expr -> expr * expr .)
    )               reduce using rule 56 (expr -> expr * expr .)
    NEQ             reduce using rule 56 (expr -> expr * expr .)
    EQ              reduce using rule 56 (expr -> expr * expr .)
    LTE             reduce using rule 56 (expr -> expr * expr .)
    <               reduce using rule 56 (expr -> expr * expr .)
    GTE             reduce using rule 56 (expr -> expr * expr .)
    >               reduce using rule 56 (expr -> expr * expr .)
    :               reduce using rule 56 (expr -> expr * expr .)
    {               reduce using rule 56 (expr -> expr * expr .)
    PRINT           reduce using rule 56 (expr -> expr * expr .)
    RETURN          reduce using rule 56 (expr -> expr * expr .)
    CONTINUE        reduce using rule 56 (expr -> expr * expr .)
    BREAK           reduce using rule 56 (expr -> expr * expr .)
    FOR             reduce using rule 56 (expr -> expr * expr .)
    WHILE           reduce using rule 56 (expr -> expr * expr .)
    IF              reduce using rule 56 (expr -> expr * expr .)
    ID              reduce using rule 56 (expr -> expr * expr .)


state 108

    (57) expr -> expr DOT_SUB expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
  ! shift/reduce conflict for DOT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for DOT_MUL resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for DOT_SUB resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for DOT_ADD resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ;               reduce using rule 57 (expr -> expr DOT_SUB expr .)
    ,               reduce using rule 57 (expr -> expr DOT_SUB expr .)
    )               reduce using rule 57 (expr -> expr DOT_SUB expr .)
    NEQ             reduce using rule 57 (expr -> expr DOT_SUB expr .)
    EQ              reduce using rule 57 (expr -> expr DOT_SUB expr .)
    LTE             reduce using rule 57 (expr -> expr DOT_SUB expr .)
    <               reduce using rule 57 (expr -> expr DOT_SUB expr .)
    GTE             reduce using rule 57 (expr -> expr DOT_SUB expr .)
    >               reduce using rule 57 (expr -> expr DOT_SUB expr .)
    :               reduce using rule 57 (expr -> expr DOT_SUB expr .)
    {               reduce using rule 57 (expr -> expr DOT_SUB expr .)
    PRINT           reduce using rule 57 (expr -> expr DOT_SUB expr .)
    RETURN          reduce using rule 57 (expr -> expr DOT_SUB expr .)
    CONTINUE        reduce using rule 57 (expr -> expr DOT_SUB expr .)
    BREAK           reduce using rule 57 (expr -> expr DOT_SUB expr .)
    FOR             reduce using rule 57 (expr -> expr DOT_SUB expr .)
    WHILE           reduce using rule 57 (expr -> expr DOT_SUB expr .)
    IF              reduce using rule 57 (expr -> expr DOT_SUB expr .)
    ID              reduce using rule 57 (expr -> expr DOT_SUB expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 109

    (58) expr -> expr - expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    DOT_DIV         reduce using rule 58 (expr -> expr - expr .)
    DOT_MUL         reduce using rule 58 (expr -> expr - expr .)
    DOT_SUB         reduce using rule 58 (expr -> expr - expr .)
    -               reduce using rule 58 (expr -> expr - expr .)
    DOT_ADD         reduce using rule 58 (expr -> expr - expr .)
    +               reduce using rule 58 (expr -> expr - expr .)
    ;               reduce using rule 58 (expr -> expr - expr .)
    ,               reduce using rule 58 (expr -> expr - expr .)
    )               reduce using rule 58 (expr -> expr - expr .)
    NEQ             reduce using rule 58 (expr -> expr - expr .)
    EQ              reduce using rule 58 (expr -> expr - expr .)
    LTE             reduce using rule 58 (expr -> expr - expr .)
    <               reduce using rule 58 (expr -> expr - expr .)
    GTE             reduce using rule 58 (expr -> expr - expr .)
    >               reduce using rule 58 (expr -> expr - expr .)
    :               reduce using rule 58 (expr -> expr - expr .)
    {               reduce using rule 58 (expr -> expr - expr .)
    PRINT           reduce using rule 58 (expr -> expr - expr .)
    RETURN          reduce using rule 58 (expr -> expr - expr .)
    CONTINUE        reduce using rule 58 (expr -> expr - expr .)
    BREAK           reduce using rule 58 (expr -> expr - expr .)
    FOR             reduce using rule 58 (expr -> expr - expr .)
    WHILE           reduce using rule 58 (expr -> expr - expr .)
    IF              reduce using rule 58 (expr -> expr - expr .)
    ID              reduce using rule 58 (expr -> expr - expr .)
    /               shift and go to state 76
    *               shift and go to state 78


state 110

    (59) expr -> expr DOT_ADD expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
  ! shift/reduce conflict for DOT_DIV resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for DOT_MUL resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for DOT_SUB resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for DOT_ADD resolved as shift
  ! shift/reduce conflict for + resolved as shift
    ;               reduce using rule 59 (expr -> expr DOT_ADD expr .)
    ,               reduce using rule 59 (expr -> expr DOT_ADD expr .)
    )               reduce using rule 59 (expr -> expr DOT_ADD expr .)
    NEQ             reduce using rule 59 (expr -> expr DOT_ADD expr .)
    EQ              reduce using rule 59 (expr -> expr DOT_ADD expr .)
    LTE             reduce using rule 59 (expr -> expr DOT_ADD expr .)
    <               reduce using rule 59 (expr -> expr DOT_ADD expr .)
    GTE             reduce using rule 59 (expr -> expr DOT_ADD expr .)
    >               reduce using rule 59 (expr -> expr DOT_ADD expr .)
    :               reduce using rule 59 (expr -> expr DOT_ADD expr .)
    {               reduce using rule 59 (expr -> expr DOT_ADD expr .)
    PRINT           reduce using rule 59 (expr -> expr DOT_ADD expr .)
    RETURN          reduce using rule 59 (expr -> expr DOT_ADD expr .)
    CONTINUE        reduce using rule 59 (expr -> expr DOT_ADD expr .)
    BREAK           reduce using rule 59 (expr -> expr DOT_ADD expr .)
    FOR             reduce using rule 59 (expr -> expr DOT_ADD expr .)
    WHILE           reduce using rule 59 (expr -> expr DOT_ADD expr .)
    IF              reduce using rule 59 (expr -> expr DOT_ADD expr .)
    ID              reduce using rule 59 (expr -> expr DOT_ADD expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 111

    (60) expr -> expr + expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    DOT_DIV         reduce using rule 60 (expr -> expr + expr .)
    DOT_MUL         reduce using rule 60 (expr -> expr + expr .)
    DOT_SUB         reduce using rule 60 (expr -> expr + expr .)
    -               reduce using rule 60 (expr -> expr + expr .)
    DOT_ADD         reduce using rule 60 (expr -> expr + expr .)
    +               reduce using rule 60 (expr -> expr + expr .)
    ;               reduce using rule 60 (expr -> expr + expr .)
    ,               reduce using rule 60 (expr -> expr + expr .)
    )               reduce using rule 60 (expr -> expr + expr .)
    NEQ             reduce using rule 60 (expr -> expr + expr .)
    EQ              reduce using rule 60 (expr -> expr + expr .)
    LTE             reduce using rule 60 (expr -> expr + expr .)
    <               reduce using rule 60 (expr -> expr + expr .)
    GTE             reduce using rule 60 (expr -> expr + expr .)
    >               reduce using rule 60 (expr -> expr + expr .)
    :               reduce using rule 60 (expr -> expr + expr .)
    {               reduce using rule 60 (expr -> expr + expr .)
    PRINT           reduce using rule 60 (expr -> expr + expr .)
    RETURN          reduce using rule 60 (expr -> expr + expr .)
    CONTINUE        reduce using rule 60 (expr -> expr + expr .)
    BREAK           reduce using rule 60 (expr -> expr + expr .)
    FOR             reduce using rule 60 (expr -> expr + expr .)
    WHILE           reduce using rule 60 (expr -> expr + expr .)
    IF              reduce using rule 60 (expr -> expr + expr .)
    ID              reduce using rule 60 (expr -> expr + expr .)
    /               shift and go to state 76
    *               shift and go to state 78


state 112

    (52) expr -> ( expr ) .
    DOT_DIV         reduce using rule 52 (expr -> ( expr ) .)
    /               reduce using rule 52 (expr -> ( expr ) .)
    DOT_MUL         reduce using rule 52 (expr -> ( expr ) .)
    *               reduce using rule 52 (expr -> ( expr ) .)
    DOT_SUB         reduce using rule 52 (expr -> ( expr ) .)
    -               reduce using rule 52 (expr -> ( expr ) .)
    DOT_ADD         reduce using rule 52 (expr -> ( expr ) .)
    +               reduce using rule 52 (expr -> ( expr ) .)
    ;               reduce using rule 52 (expr -> ( expr ) .)
    ,               reduce using rule 52 (expr -> ( expr ) .)
    )               reduce using rule 52 (expr -> ( expr ) .)
    NEQ             reduce using rule 52 (expr -> ( expr ) .)
    EQ              reduce using rule 52 (expr -> ( expr ) .)
    LTE             reduce using rule 52 (expr -> ( expr ) .)
    <               reduce using rule 52 (expr -> ( expr ) .)
    GTE             reduce using rule 52 (expr -> ( expr ) .)
    >               reduce using rule 52 (expr -> ( expr ) .)
    :               reduce using rule 52 (expr -> ( expr ) .)
    {               reduce using rule 52 (expr -> ( expr ) .)
    PRINT           reduce using rule 52 (expr -> ( expr ) .)
    RETURN          reduce using rule 52 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 52 (expr -> ( expr ) .)
    BREAK           reduce using rule 52 (expr -> ( expr ) .)
    FOR             reduce using rule 52 (expr -> ( expr ) .)
    WHILE           reduce using rule 52 (expr -> ( expr ) .)
    IF              reduce using rule 52 (expr -> ( expr ) .)
    ID              reduce using rule 52 (expr -> ( expr ) .)


state 113

    (32) matrix -> EYE ( INTNUM . )
    )               shift and go to state 132


state 114

    (33) matrix -> ONES ( INTNUM . )
    )               shift and go to state 133


state 115

    (34) matrix -> ZEROS ( INTNUM . )
    )               shift and go to state 134


state 116

    (43) rows2 -> [ row . ]
    (46) row -> row . , INTNUM
    ]               shift and go to state 135
    ,               shift and go to state 102


state 117

    (42) matrix2 -> [ rows2 ] .
    '               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    DOT_DIV         reduce using rule 42 (matrix2 -> [ rows2 ] .)
    /               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    DOT_MUL         reduce using rule 42 (matrix2 -> [ rows2 ] .)
    *               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    DOT_SUB         reduce using rule 42 (matrix2 -> [ rows2 ] .)
    -               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    DOT_ADD         reduce using rule 42 (matrix2 -> [ rows2 ] .)
    +               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    ;               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    ,               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    )               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    NEQ             reduce using rule 42 (matrix2 -> [ rows2 ] .)
    EQ              reduce using rule 42 (matrix2 -> [ rows2 ] .)
    LTE             reduce using rule 42 (matrix2 -> [ rows2 ] .)
    <               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    GTE             reduce using rule 42 (matrix2 -> [ rows2 ] .)
    >               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    :               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    {               reduce using rule 42 (matrix2 -> [ rows2 ] .)
    PRINT           reduce using rule 42 (matrix2 -> [ rows2 ] .)
    RETURN          reduce using rule 42 (matrix2 -> [ rows2 ] .)
    CONTINUE        reduce using rule 42 (matrix2 -> [ rows2 ] .)
    BREAK           reduce using rule 42 (matrix2 -> [ rows2 ] .)
    FOR             reduce using rule 42 (matrix2 -> [ rows2 ] .)
    WHILE           reduce using rule 42 (matrix2 -> [ rows2 ] .)
    IF              reduce using rule 42 (matrix2 -> [ rows2 ] .)
    ID              reduce using rule 42 (matrix2 -> [ rows2 ] .)


state 118

    (44) rows2 -> rows2 , . [ row ]
    [               shift and go to state 136


state 119

    (39) matrix1 -> [ rows1 ] .
    '               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    DOT_DIV         reduce using rule 39 (matrix1 -> [ rows1 ] .)
    /               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    DOT_MUL         reduce using rule 39 (matrix1 -> [ rows1 ] .)
    *               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    DOT_SUB         reduce using rule 39 (matrix1 -> [ rows1 ] .)
    -               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    DOT_ADD         reduce using rule 39 (matrix1 -> [ rows1 ] .)
    +               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    ;               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    ,               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    )               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    NEQ             reduce using rule 39 (matrix1 -> [ rows1 ] .)
    EQ              reduce using rule 39 (matrix1 -> [ rows1 ] .)
    LTE             reduce using rule 39 (matrix1 -> [ rows1 ] .)
    <               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    GTE             reduce using rule 39 (matrix1 -> [ rows1 ] .)
    >               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    :               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    {               reduce using rule 39 (matrix1 -> [ rows1 ] .)
    PRINT           reduce using rule 39 (matrix1 -> [ rows1 ] .)
    RETURN          reduce using rule 39 (matrix1 -> [ rows1 ] .)
    CONTINUE        reduce using rule 39 (matrix1 -> [ rows1 ] .)
    BREAK           reduce using rule 39 (matrix1 -> [ rows1 ] .)
    FOR             reduce using rule 39 (matrix1 -> [ rows1 ] .)
    WHILE           reduce using rule 39 (matrix1 -> [ rows1 ] .)
    IF              reduce using rule 39 (matrix1 -> [ rows1 ] .)
    ID              reduce using rule 39 (matrix1 -> [ rows1 ] .)


state 120

    (41) rows1 -> rows1 ; . row
    (45) row -> . INTNUM
    (46) row -> . row , INTNUM
    INTNUM          shift and go to state 67

    row                            shift and go to state 137

state 121

    (23) for_statement -> FOR ID = expr . : expr statement
    (24) for_statement -> FOR ID = expr . : expr { statements }
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    :               shift and go to state 138
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 122

    (21) while_statement -> WHILE ( relative ) . statement
    (22) while_statement -> WHILE ( relative ) . { statements }
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    {               shift and go to state 140
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    statement                      shift and go to state 139
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 123

    (62) relative -> expr NEQ . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 141
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 124

    (63) relative -> expr EQ . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 142
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 125

    (64) relative -> expr LTE . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 143
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 126

    (65) relative -> expr < . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 144
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 127

    (66) relative -> expr GTE . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 145
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 128

    (67) relative -> expr > . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 146
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 129

    (19) if_statement -> IF ( relative ) . { statement }
    (20) if_statement -> IF ( relative ) . statement
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    {               shift and go to state 147
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    statement                      shift and go to state 148
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 130

    (29) mul_assign -> ID [ row ] = . expr
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 149
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 131

    (46) row -> row , INTNUM .
    ]               reduce using rule 46 (row -> row , INTNUM .)
    ,               reduce using rule 46 (row -> row , INTNUM .)
    ;               reduce using rule 46 (row -> row , INTNUM .)


state 132

    (32) matrix -> EYE ( INTNUM ) .
    '               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    DOT_DIV         reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    /               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    DOT_MUL         reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    *               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    DOT_SUB         reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    -               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    DOT_ADD         reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    +               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    ;               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    ,               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    )               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    NEQ             reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    EQ              reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    LTE             reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    <               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    GTE             reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    >               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    :               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    {               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    PRINT           reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    RETURN          reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    CONTINUE        reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    BREAK           reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    FOR             reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    WHILE           reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    IF              reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    ID              reduce using rule 32 (matrix -> EYE ( INTNUM ) .)


state 133

    (33) matrix -> ONES ( INTNUM ) .
    '               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    DOT_DIV         reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    /               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    DOT_MUL         reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    *               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    DOT_SUB         reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    -               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    DOT_ADD         reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    +               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    ;               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    ,               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    )               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    NEQ             reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    EQ              reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    LTE             reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    <               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    GTE             reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    >               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    :               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    {               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    PRINT           reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    RETURN          reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    CONTINUE        reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    BREAK           reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    FOR             reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    WHILE           reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    IF              reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    ID              reduce using rule 33 (matrix -> ONES ( INTNUM ) .)


state 134

    (34) matrix -> ZEROS ( INTNUM ) .
    '               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    DOT_DIV         reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    /               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    DOT_MUL         reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    *               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    DOT_SUB         reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    -               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    DOT_ADD         reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    +               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    ;               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    ,               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    )               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    NEQ             reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    EQ              reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    LTE             reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    <               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    GTE             reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    >               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    :               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    {               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    PRINT           reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    RETURN          reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    CONTINUE        reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    BREAK           reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    FOR             reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    WHILE           reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    IF              reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    ID              reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)


state 135

    (43) rows2 -> [ row ] .
    ]               reduce using rule 43 (rows2 -> [ row ] .)
    ,               reduce using rule 43 (rows2 -> [ row ] .)


state 136

    (44) rows2 -> rows2 , [ . row ]
    (45) row -> . INTNUM
    (46) row -> . row , INTNUM
    INTNUM          shift and go to state 67

    row                            shift and go to state 150

state 137

    (41) rows1 -> rows1 ; row .
    (46) row -> row . , INTNUM
    ]               reduce using rule 41 (rows1 -> rows1 ; row .)
    ;               reduce using rule 41 (rows1 -> rows1 ; row .)
    ,               shift and go to state 102


state 138

    (23) for_statement -> FOR ID = expr : . expr statement
    (24) for_statement -> FOR ID = expr : . expr { statements }
    (47) expr -> . ID
    (48) expr -> . ID '
    (49) expr -> . FLOATNUM
    (50) expr -> . INTNUM
    (51) expr -> . matrix
    (52) expr -> . ( expr )
    (53) expr -> . expr DOT_DIV expr
    (54) expr -> . expr / expr
    (55) expr -> . expr DOT_MUL expr
    (56) expr -> . expr * expr
    (57) expr -> . expr DOT_SUB expr
    (58) expr -> . expr - expr
    (59) expr -> . expr DOT_ADD expr
    (60) expr -> . expr + expr
    (61) expr -> . - expr
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (42) matrix2 -> . [ rows2 ]
    (39) matrix1 -> . [ rows1 ]
    ID              shift and go to state 63
    FLOATNUM        shift and go to state 65
    INTNUM          shift and go to state 42
    (               shift and go to state 44
    -               shift and go to state 45
    EYE             shift and go to state 46
    ONES            shift and go to state 47
    ZEROS           shift and go to state 48
    [               shift and go to state 51

    expr                           shift and go to state 151
    matrix                         shift and go to state 43
    matrix2                        shift and go to state 49
    matrix1                        shift and go to state 50

state 139

    (21) while_statement -> WHILE ( relative ) statement .
    PRINT           reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    RETURN          reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    CONTINUE        reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    BREAK           reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    FOR             reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    WHILE           reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    IF              reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    ID              reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    $end            reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    ELSE            reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)
    }               reduce using rule 21 (while_statement -> WHILE ( relative ) statement .)


state 140

    (22) while_statement -> WHILE ( relative ) { . statements }
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    statements                     shift and go to state 152
    statement                      shift and go to state 3
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 141

    (62) relative -> expr NEQ expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    )               reduce using rule 62 (relative -> expr NEQ expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 142

    (63) relative -> expr EQ expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    )               reduce using rule 63 (relative -> expr EQ expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 143

    (64) relative -> expr LTE expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    )               reduce using rule 64 (relative -> expr LTE expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 144

    (65) relative -> expr < expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    )               reduce using rule 65 (relative -> expr < expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 145

    (66) relative -> expr GTE expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    )               reduce using rule 66 (relative -> expr GTE expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 146

    (67) relative -> expr > expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    )               reduce using rule 67 (relative -> expr > expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 147

    (19) if_statement -> IF ( relative ) { . statement }
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    statement                      shift and go to state 153
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 148

    (20) if_statement -> IF ( relative ) statement .
    ELSE            reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    PRINT           reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    RETURN          reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    CONTINUE        reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    BREAK           reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    FOR             reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    WHILE           reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    IF              reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    ID              reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    $end            reduce using rule 20 (if_statement -> IF ( relative ) statement .)
    }               reduce using rule 20 (if_statement -> IF ( relative ) statement .)


state 149

    (29) mul_assign -> ID [ row ] = expr .
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    ;               reduce using rule 29 (mul_assign -> ID [ row ] = expr .)
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82


state 150

    (44) rows2 -> rows2 , [ row . ]
    (46) row -> row . , INTNUM
    ]               shift and go to state 154
    ,               shift and go to state 102


state 151

    (23) for_statement -> FOR ID = expr : expr . statement
    (24) for_statement -> FOR ID = expr : expr . { statements }
    (53) expr -> expr . DOT_DIV expr
    (54) expr -> expr . / expr
    (55) expr -> expr . DOT_MUL expr
    (56) expr -> expr . * expr
    (57) expr -> expr . DOT_SUB expr
    (58) expr -> expr . - expr
    (59) expr -> expr . DOT_ADD expr
    (60) expr -> expr . + expr
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    {               shift and go to state 156
    DOT_DIV         shift and go to state 75
    /               shift and go to state 76
    DOT_MUL         shift and go to state 77
    *               shift and go to state 78
    DOT_SUB         shift and go to state 79
    -               shift and go to state 80
    DOT_ADD         shift and go to state 81
    +               shift and go to state 82
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    statement                      shift and go to state 155
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 152

    (22) while_statement -> WHILE ( relative ) { statements . }
    (3) statements -> statements . statement
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    }               shift and go to state 157
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    statement                      shift and go to state 20
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 153

    (19) if_statement -> IF ( relative ) { statement . }
    }               shift and go to state 158


state 154

    (44) rows2 -> rows2 , [ row ] .
    ]               reduce using rule 44 (rows2 -> rows2 , [ row ] .)
    ,               reduce using rule 44 (rows2 -> rows2 , [ row ] .)


state 155

    (23) for_statement -> FOR ID = expr : expr statement .
    PRINT           reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    RETURN          reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    CONTINUE        reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    BREAK           reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    FOR             reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    WHILE           reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    IF              reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    ID              reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    $end            reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    ELSE            reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)
    }               reduce using rule 23 (for_statement -> FOR ID = expr : expr statement .)


state 156

    (24) for_statement -> FOR ID = expr : expr { . statements }
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    statements                     shift and go to state 159
    statement                      shift and go to state 3
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 157

    (22) while_statement -> WHILE ( relative ) { statements } .
    PRINT           reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    RETURN          reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    CONTINUE        reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    BREAK           reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    FOR             reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    WHILE           reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    IF              reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    ID              reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    $end            reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    ELSE            reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)
    }               reduce using rule 22 (while_statement -> WHILE ( relative ) { statements } .)


state 158

    (19) if_statement -> IF ( relative ) { statement } .
    ELSE            reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    PRINT           reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    RETURN          reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    CONTINUE        reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    BREAK           reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    FOR             reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    WHILE           reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    IF              reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    ID              reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    $end            reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)
    }               reduce using rule 19 (if_statement -> IF ( relative ) { statement } .)


state 159

    (24) for_statement -> FOR ID = expr : expr { statements . }
    (3) statements -> statements . statement
    (4) statement -> . for_statement
    (5) statement -> . while_statement
    (6) statement -> . if_statement
    (7) statement -> . PRINT print_values ;
    (8) statement -> . PRINT ID ;
    (9) statement -> . div_assign ;
    (10) statement -> . mul_assign ;
    (11) statement -> . sub_assign ;
    (12) statement -> . add_assign ;
    (13) statement -> . RETURN return_values ;
    (14) statement -> . CONTINUE ;
    (15) statement -> . BREAK ;
    (16) statement -> . assign ;
    (23) for_statement -> . FOR ID = expr : expr statement
    (24) for_statement -> . FOR ID = expr : expr { statements }
    (21) while_statement -> . WHILE ( relative ) statement
    (22) while_statement -> . WHILE ( relative ) { statements }
    (17) if_statement -> . if_statement ELSE statements
    (18) if_statement -> . if_statement ELSE if_statement
    (19) if_statement -> . IF ( relative ) { statement }
    (20) if_statement -> . IF ( relative ) statement
    (31) div_assign -> . ID DIV_ASSIGN expr
    (29) mul_assign -> . ID [ row ] = expr
    (30) mul_assign -> . ID MUL_ASSIGN expr
    (28) sub_assign -> . ID SUB_ASSIGN expr
    (27) add_assign -> . ID ADD_ASSIGN expr
    (25) assign -> . ID = STRING
    (26) assign -> . ID = expr
    }               shift and go to state 160
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 18
    IF              shift and go to state 19
    ID              shift and go to state 8

    statement                      shift and go to state 20
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 160

    (24) for_statement -> FOR ID = expr : expr { statements } .
    PRINT           reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    RETURN          reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    CONTINUE        reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    BREAK           reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    FOR             reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    WHILE           reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    IF              reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    ID              reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    $end            reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    ELSE            reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)
    }               reduce using rule 24 (for_statement -> FOR ID = expr : expr { statements } .)


Conflicts:

shift/reduce conflict for ELSE in state 6 resolved as shift
shift/reduce conflict for ; in state 23 resolved as shift
shift/reduce conflict for ELSE in state 58 resolved as shift
shift/reduce conflict for DOT_DIV in state 104 resolved as shift
shift/reduce conflict for / in state 104 resolved as shift
shift/reduce conflict for DOT_MUL in state 104 resolved as shift
shift/reduce conflict for * in state 104 resolved as shift
shift/reduce conflict for DOT_SUB in state 104 resolved as shift
shift/reduce conflict for - in state 104 resolved as shift
shift/reduce conflict for DOT_ADD in state 104 resolved as shift
shift/reduce conflict for + in state 104 resolved as shift
shift/reduce conflict for DOT_DIV in state 106 resolved as shift
shift/reduce conflict for / in state 106 resolved as shift
shift/reduce conflict for DOT_MUL in state 106 resolved as shift
shift/reduce conflict for * in state 106 resolved as shift
shift/reduce conflict for DOT_SUB in state 106 resolved as shift
shift/reduce conflict for - in state 106 resolved as shift
shift/reduce conflict for DOT_ADD in state 106 resolved as shift
shift/reduce conflict for + in state 106 resolved as shift
shift/reduce conflict for DOT_DIV in state 108 resolved as shift
shift/reduce conflict for / in state 108 resolved as shift
shift/reduce conflict for DOT_MUL in state 108 resolved as shift
shift/reduce conflict for * in state 108 resolved as shift
shift/reduce conflict for DOT_SUB in state 108 resolved as shift
shift/reduce conflict for - in state 108 resolved as shift
shift/reduce conflict for DOT_ADD in state 108 resolved as shift
shift/reduce conflict for + in state 108 resolved as shift
shift/reduce conflict for DOT_DIV in state 110 resolved as shift
shift/reduce conflict for / in state 110 resolved as shift
shift/reduce conflict for DOT_MUL in state 110 resolved as shift
shift/reduce conflict for * in state 110 resolved as shift
shift/reduce conflict for DOT_SUB in state 110 resolved as shift
shift/reduce conflict for - in state 110 resolved as shift
shift/reduce conflict for DOT_ADD in state 110 resolved as shift
shift/reduce conflict for + in state 110 resolved as shift
reduce/reduce conflict in state 39 resolved using rule expr -> FLOATNUM
rejected rule (return_value -> FLOATNUM) in state 39
reduce/reduce conflict in state 40 resolved using rule expr -> ID
rejected rule (return_value -> ID) in state 40
reduce/reduce conflict in state 58 resolved using rule statement -> if_statement
rejected rule (if_statement -> if_statement ELSE if_statement  [precedence=right, level=4]) in state 58
Rule (return_value -> FLOATNUM) is never reduced
Rule (return_value -> ID) is never reduced
Rule (if_statement -> if_statement ELSE if_statement  [precedence=right, level=4]) is never reduced