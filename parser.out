Grammar:

Rule 0     S' -> program
Rule 1     program -> lines
Rule 2     lines -> line
Rule 3     lines -> lines line
Rule 4     line -> for_statement
Rule 5     line -> while_statement
Rule 6     line -> if_statement
Rule 7     line -> PRINT statement_values ;
Rule 8     line -> matrix_assign ;
Rule 9     line -> div_assign ;
Rule 10    line -> mul_assign ;
Rule 11    line -> sub_assign ;
Rule 12    line -> add_assign ;
Rule 13    line -> RETURN statement_values ;
Rule 14    line -> CONTINUE ;
Rule 15    line -> BREAK ;
Rule 16    line -> assign ;
Rule 17    block -> { lines }
Rule 18    block -> line
Rule 19    if_statement -> if_statement ELSE if_statement  [precedence=right, level=1]
Rule 20    if_statement -> if_statement ELSE block  [precedence=right, level=1]
Rule 21    if_statement -> IF ( relative ) block
Rule 22    while_statement -> WHILE ( relative ) block
Rule 23    for_statement -> FOR variable = expr : expr block
Rule 24    assign -> variable = STRING
Rule 25    assign -> variable = expr
Rule 26    add_assign -> variable ADD_ASSIGN expr  [precedence=right, level=2]
Rule 27    sub_assign -> variable SUB_ASSIGN expr  [precedence=right, level=2]
Rule 28    mul_assign -> variable MUL_ASSIGN expr  [precedence=right, level=2]
Rule 29    div_assign -> variable DIV_ASSIGN expr  [precedence=right, level=2]
Rule 30    matrix_assign -> ID [ index ] = expr
Rule 31    matrix_assign -> ID [ indexes ] = expr
Rule 32    matrix -> EYE ( INTNUM )
Rule 33    matrix -> ONES ( INTNUM )
Rule 34    matrix -> ZEROS ( INTNUM )
Rule 35    matrix -> matrix2
Rule 36    matrix -> matrix1
Rule 37    matrix -> [ ]
Rule 38    matrix -> matrix '  [precedence=left, level=9]
Rule 39    indexes -> INTNUM , INTNUM
Rule 40    index -> INTNUM
Rule 41    matrix1 -> [ rows1 ]
Rule 42    rows1 -> row
Rule 43    rows1 -> rows1 ; row
Rule 44    matrix2 -> [ rows2 ]
Rule 45    rows2 -> [ row ]
Rule 46    rows2 -> rows2 , [ row ]
Rule 47    row -> number
Rule 48    row -> row , number
Rule 49    number -> FLOATNUM
Rule 50    number -> INTNUM
Rule 51    expr -> variable
Rule 52    expr -> variable '  [precedence=left, level=9]
Rule 53    expr -> number
Rule 54    expr -> matrix
Rule 55    expr -> ( expr )
Rule 56    expr -> expr DOT_DIV expr  [precedence=left, level=7]
Rule 57    expr -> expr / expr  [precedence=left, level=5]
Rule 58    expr -> expr DOT_MUL expr  [precedence=left, level=7]
Rule 59    expr -> expr * expr  [precedence=left, level=5]
Rule 60    expr -> expr DOT_SUB expr  [precedence=left, level=6]
Rule 61    expr -> expr - expr  [precedence=left, level=4]
Rule 62    expr -> expr DOT_ADD expr  [precedence=left, level=6]
Rule 63    expr -> expr + expr  [precedence=left, level=4]
Rule 64    expr -> - expr  [precedence=right, level=8]
Rule 65    variable -> ID
Rule 66    rel_op -> LTE  [precedence=nonassoc, level=3]
Rule 67    rel_op -> GTE  [precedence=nonassoc, level=3]
Rule 68    rel_op -> NEQ  [precedence=nonassoc, level=3]
Rule 69    rel_op -> EQ  [precedence=nonassoc, level=3]
Rule 70    rel_op -> <  [precedence=nonassoc, level=3]
Rule 71    rel_op -> >  [precedence=nonassoc, level=3]
Rule 72    relative -> expr rel_op expr
Rule 73    statement_values -> statement_value
Rule 74    statement_values -> statement_values , statement_value
Rule 75    statement_value -> variable
Rule 76    statement_value -> expr
Rule 77    statement_value -> STRING

Terminals, with rules where they appear:

'                    : 38 52
(                    : 21 22 32 33 34 55
)                    : 21 22 32 33 34 55
*                    : 59
+                    : 63
,                    : 39 46 48 74
-                    : 61 64
/                    : 57
:                    : 23
;                    : 7 8 9 10 11 12 13 14 15 16 43
<                    : 70
=                    : 23 24 25 30 31
>                    : 71
ADD_ASSIGN           : 26
BREAK                : 15
CONTINUE             : 14
DIV_ASSIGN           : 29
DOT_ADD              : 62
DOT_DIV              : 56
DOT_MUL              : 58
DOT_SUB              : 60
ELSE                 : 19 20
EQ                   : 69
EYE                  : 32
FLOATNUM             : 49
FOR                  : 23
GTE                  : 67
ID                   : 30 31 65
IF                   : 21
INTNUM               : 32 33 34 39 39 40 50
LTE                  : 66
MUL_ASSIGN           : 28
NEQ                  : 68
ONES                 : 33
PRINT                : 7
RETURN               : 13
STRING               : 24 77
SUB_ASSIGN           : 27
WHILE                : 22
ZEROS                : 34
[                    : 30 31 37 41 44 45 46
]                    : 30 31 37 41 44 45 46
error                : 
{                    : 17
}                    : 17

Nonterminals, with rules where they appear:

add_assign           : 12
assign               : 16
block                : 20 21 22 23
div_assign           : 9
expr                 : 23 23 25 26 27 28 29 30 31 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 72 72 76
for_statement        : 4
if_statement         : 6 19 19 20
index                : 30
indexes              : 31
line                 : 2 3 18
lines                : 1 3 17
matrix               : 38 54
matrix1              : 36
matrix2              : 35
matrix_assign        : 8
mul_assign           : 10
number               : 47 48 53
program              : 0
rel_op               : 72
relative             : 21 22
row                  : 42 43 45 46 48
rows1                : 41 43
rows2                : 44 46
statement_value      : 73 74
statement_values     : 7 13 74
sub_assign           : 11
variable             : 23 24 25 26 27 28 29 51 52 75
while_statement      : 5


state 0

    (0) S' -> . program
    (1) program -> . lines
    (2) lines -> . line
    (3) lines -> . lines line
    (4) line -> . for_statement
    (5) line -> . while_statement
    (6) line -> . if_statement
    (7) line -> . PRINT statement_values ;
    (8) line -> . matrix_assign ;
    (9) line -> . div_assign ;
    (10) line -> . mul_assign ;
    (11) line -> . sub_assign ;
    (12) line -> . add_assign ;
    (13) line -> . RETURN statement_values ;
    (14) line -> . CONTINUE ;
    (15) line -> . BREAK ;
    (16) line -> . assign ;
    (23) for_statement -> . FOR variable = expr : expr block
    (22) while_statement -> . WHILE ( relative ) block
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE block
    (21) if_statement -> . IF ( relative ) block
    (30) matrix_assign -> . ID [ index ] = expr
    (31) matrix_assign -> . ID [ indexes ] = expr
    (29) div_assign -> . variable DIV_ASSIGN expr
    (28) mul_assign -> . variable MUL_ASSIGN expr
    (27) sub_assign -> . variable SUB_ASSIGN expr
    (26) add_assign -> . variable ADD_ASSIGN expr
    (24) assign -> . variable = STRING
    (25) assign -> . variable = expr
    (65) variable -> . ID
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 21

    program                        shift and go to state 1
    lines                          shift and go to state 2
    line                           shift and go to state 3
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    matrix_assign                  shift and go to state 8
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16
    variable                       shift and go to state 18

state 1

    (0) S' -> program .


state 2

    (1) program -> lines .
    (3) lines -> lines . line
    (4) line -> . for_statement
    (5) line -> . while_statement
    (6) line -> . if_statement
    (7) line -> . PRINT statement_values ;
    (8) line -> . matrix_assign ;
    (9) line -> . div_assign ;
    (10) line -> . mul_assign ;
    (11) line -> . sub_assign ;
    (12) line -> . add_assign ;
    (13) line -> . RETURN statement_values ;
    (14) line -> . CONTINUE ;
    (15) line -> . BREAK ;
    (16) line -> . assign ;
    (23) for_statement -> . FOR variable = expr : expr block
    (22) while_statement -> . WHILE ( relative ) block
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE block
    (21) if_statement -> . IF ( relative ) block
    (30) matrix_assign -> . ID [ index ] = expr
    (31) matrix_assign -> . ID [ indexes ] = expr
    (29) div_assign -> . variable DIV_ASSIGN expr
    (28) mul_assign -> . variable MUL_ASSIGN expr
    (27) sub_assign -> . variable SUB_ASSIGN expr
    (26) add_assign -> . variable ADD_ASSIGN expr
    (24) assign -> . variable = STRING
    (25) assign -> . variable = expr
    (65) variable -> . ID
    $end            reduce using rule 1 (program -> lines .)
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 21

    line                           shift and go to state 22
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    matrix_assign                  shift and go to state 8
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16
    variable                       shift and go to state 18

state 3

    (2) lines -> line .
    PRINT           reduce using rule 2 (lines -> line .)
    RETURN          reduce using rule 2 (lines -> line .)
    CONTINUE        reduce using rule 2 (lines -> line .)
    BREAK           reduce using rule 2 (lines -> line .)
    FOR             reduce using rule 2 (lines -> line .)
    WHILE           reduce using rule 2 (lines -> line .)
    IF              reduce using rule 2 (lines -> line .)
    ID              reduce using rule 2 (lines -> line .)
    $end            reduce using rule 2 (lines -> line .)
    }               reduce using rule 2 (lines -> line .)


state 4

    (4) line -> for_statement .
    PRINT           reduce using rule 4 (line -> for_statement .)
    RETURN          reduce using rule 4 (line -> for_statement .)
    CONTINUE        reduce using rule 4 (line -> for_statement .)
    BREAK           reduce using rule 4 (line -> for_statement .)
    FOR             reduce using rule 4 (line -> for_statement .)
    WHILE           reduce using rule 4 (line -> for_statement .)
    IF              reduce using rule 4 (line -> for_statement .)
    ID              reduce using rule 4 (line -> for_statement .)
    $end            reduce using rule 4 (line -> for_statement .)
    ELSE            reduce using rule 4 (line -> for_statement .)
    }               reduce using rule 4 (line -> for_statement .)


state 5

    (5) line -> while_statement .
    PRINT           reduce using rule 5 (line -> while_statement .)
    RETURN          reduce using rule 5 (line -> while_statement .)
    CONTINUE        reduce using rule 5 (line -> while_statement .)
    BREAK           reduce using rule 5 (line -> while_statement .)
    FOR             reduce using rule 5 (line -> while_statement .)
    WHILE           reduce using rule 5 (line -> while_statement .)
    IF              reduce using rule 5 (line -> while_statement .)
    ID              reduce using rule 5 (line -> while_statement .)
    $end            reduce using rule 5 (line -> while_statement .)
    ELSE            reduce using rule 5 (line -> while_statement .)
    }               reduce using rule 5 (line -> while_statement .)


state 6

    (6) line -> if_statement .
    (19) if_statement -> if_statement . ELSE if_statement
    (20) if_statement -> if_statement . ELSE block
  ! shift/reduce conflict for ELSE resolved as shift
    PRINT           reduce using rule 6 (line -> if_statement .)
    RETURN          reduce using rule 6 (line -> if_statement .)
    CONTINUE        reduce using rule 6 (line -> if_statement .)
    BREAK           reduce using rule 6 (line -> if_statement .)
    FOR             reduce using rule 6 (line -> if_statement .)
    WHILE           reduce using rule 6 (line -> if_statement .)
    IF              reduce using rule 6 (line -> if_statement .)
    ID              reduce using rule 6 (line -> if_statement .)
    $end            reduce using rule 6 (line -> if_statement .)
    }               reduce using rule 6 (line -> if_statement .)
    ELSE            shift and go to state 23


state 7

    (7) line -> PRINT . statement_values ;
    (73) statement_values -> . statement_value
    (74) statement_values -> . statement_values , statement_value
    (75) statement_value -> . variable
    (76) statement_value -> . expr
    (77) statement_value -> . STRING
    (65) variable -> . ID
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    STRING          shift and go to state 28
    ID              shift and go to state 29
    (               shift and go to state 32
    -               shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    statement_values               shift and go to state 24
    statement_value                shift and go to state 25
    variable                       shift and go to state 26
    expr                           shift and go to state 27
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 8

    (8) line -> matrix_assign . ;
    ;               shift and go to state 42


state 9

    (9) line -> div_assign . ;
    ;               shift and go to state 43


state 10

    (10) line -> mul_assign . ;
    ;               shift and go to state 44


state 11

    (11) line -> sub_assign . ;
    ;               shift and go to state 45


state 12

    (12) line -> add_assign . ;
    ;               shift and go to state 46


state 13

    (13) line -> RETURN . statement_values ;
    (73) statement_values -> . statement_value
    (74) statement_values -> . statement_values , statement_value
    (75) statement_value -> . variable
    (76) statement_value -> . expr
    (77) statement_value -> . STRING
    (65) variable -> . ID
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    STRING          shift and go to state 28
    ID              shift and go to state 29
    (               shift and go to state 32
    -               shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    statement_values               shift and go to state 47
    statement_value                shift and go to state 25
    variable                       shift and go to state 26
    expr                           shift and go to state 27
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 14

    (14) line -> CONTINUE . ;
    ;               shift and go to state 48


state 15

    (15) line -> BREAK . ;
    ;               shift and go to state 49


state 16

    (16) line -> assign . ;
    ;               shift and go to state 50


state 17

    (23) for_statement -> FOR . variable = expr : expr block
    (65) variable -> . ID
    ID              shift and go to state 29

    variable                       shift and go to state 51

state 18

    (29) div_assign -> variable . DIV_ASSIGN expr
    (28) mul_assign -> variable . MUL_ASSIGN expr
    (27) sub_assign -> variable . SUB_ASSIGN expr
    (26) add_assign -> variable . ADD_ASSIGN expr
    (24) assign -> variable . = STRING
    (25) assign -> variable . = expr
    DIV_ASSIGN      shift and go to state 52
    MUL_ASSIGN      shift and go to state 53
    SUB_ASSIGN      shift and go to state 54
    ADD_ASSIGN      shift and go to state 55
    =               shift and go to state 56


state 19

    (22) while_statement -> WHILE . ( relative ) block
    (               shift and go to state 57


state 20

    (21) if_statement -> IF . ( relative ) block
    (               shift and go to state 58


state 21

    (30) matrix_assign -> ID . [ index ] = expr
    (31) matrix_assign -> ID . [ indexes ] = expr
    (65) variable -> ID .
    [               shift and go to state 59
    DIV_ASSIGN      reduce using rule 65 (variable -> ID .)
    MUL_ASSIGN      reduce using rule 65 (variable -> ID .)
    SUB_ASSIGN      reduce using rule 65 (variable -> ID .)
    ADD_ASSIGN      reduce using rule 65 (variable -> ID .)
    =               reduce using rule 65 (variable -> ID .)


state 22

    (3) lines -> lines line .
    PRINT           reduce using rule 3 (lines -> lines line .)
    RETURN          reduce using rule 3 (lines -> lines line .)
    CONTINUE        reduce using rule 3 (lines -> lines line .)
    BREAK           reduce using rule 3 (lines -> lines line .)
    FOR             reduce using rule 3 (lines -> lines line .)
    WHILE           reduce using rule 3 (lines -> lines line .)
    IF              reduce using rule 3 (lines -> lines line .)
    ID              reduce using rule 3 (lines -> lines line .)
    $end            reduce using rule 3 (lines -> lines line .)
    }               reduce using rule 3 (lines -> lines line .)


state 23

    (19) if_statement -> if_statement ELSE . if_statement
    (20) if_statement -> if_statement ELSE . block
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE block
    (21) if_statement -> . IF ( relative ) block
    (17) block -> . { lines }
    (18) block -> . line
    (4) line -> . for_statement
    (5) line -> . while_statement
    (6) line -> . if_statement
    (7) line -> . PRINT statement_values ;
    (8) line -> . matrix_assign ;
    (9) line -> . div_assign ;
    (10) line -> . mul_assign ;
    (11) line -> . sub_assign ;
    (12) line -> . add_assign ;
    (13) line -> . RETURN statement_values ;
    (14) line -> . CONTINUE ;
    (15) line -> . BREAK ;
    (16) line -> . assign ;
    (23) for_statement -> . FOR variable = expr : expr block
    (22) while_statement -> . WHILE ( relative ) block
    (30) matrix_assign -> . ID [ index ] = expr
    (31) matrix_assign -> . ID [ indexes ] = expr
    (29) div_assign -> . variable DIV_ASSIGN expr
    (28) mul_assign -> . variable MUL_ASSIGN expr
    (27) sub_assign -> . variable SUB_ASSIGN expr
    (26) add_assign -> . variable ADD_ASSIGN expr
    (24) assign -> . variable = STRING
    (25) assign -> . variable = expr
    (65) variable -> . ID
    IF              shift and go to state 20
    {               shift and go to state 62
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    ID              shift and go to state 21

    if_statement                   shift and go to state 60
    block                          shift and go to state 61
    line                           shift and go to state 63
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    matrix_assign                  shift and go to state 8
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16
    variable                       shift and go to state 18

state 24

    (7) line -> PRINT statement_values . ;
    (74) statement_values -> statement_values . , statement_value
    ;               shift and go to state 64
    ,               shift and go to state 65


state 25

    (73) statement_values -> statement_value .
    ;               reduce using rule 73 (statement_values -> statement_value .)
    ,               reduce using rule 73 (statement_values -> statement_value .)


state 26

    (75) statement_value -> variable .
    (51) expr -> variable .
    (52) expr -> variable . '
  ! reduce/reduce conflict for ; resolved using rule 51 (expr -> variable .)
  ! reduce/reduce conflict for , resolved using rule 51 (expr -> variable .)
    DOT_DIV         reduce using rule 51 (expr -> variable .)
    /               reduce using rule 51 (expr -> variable .)
    DOT_MUL         reduce using rule 51 (expr -> variable .)
    *               reduce using rule 51 (expr -> variable .)
    DOT_SUB         reduce using rule 51 (expr -> variable .)
    -               reduce using rule 51 (expr -> variable .)
    DOT_ADD         reduce using rule 51 (expr -> variable .)
    +               reduce using rule 51 (expr -> variable .)
    ;               reduce using rule 51 (expr -> variable .)
    ,               reduce using rule 51 (expr -> variable .)
    '               shift and go to state 66


state 27

    (76) statement_value -> expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    ;               reduce using rule 76 (statement_value -> expr .)
    ,               reduce using rule 76 (statement_value -> expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 28

    (77) statement_value -> STRING .
    ;               reduce using rule 77 (statement_value -> STRING .)
    ,               reduce using rule 77 (statement_value -> STRING .)


state 29

    (65) variable -> ID .
    '               reduce using rule 65 (variable -> ID .)
    ;               reduce using rule 65 (variable -> ID .)
    ,               reduce using rule 65 (variable -> ID .)
    DOT_DIV         reduce using rule 65 (variable -> ID .)
    /               reduce using rule 65 (variable -> ID .)
    DOT_MUL         reduce using rule 65 (variable -> ID .)
    *               reduce using rule 65 (variable -> ID .)
    DOT_SUB         reduce using rule 65 (variable -> ID .)
    -               reduce using rule 65 (variable -> ID .)
    DOT_ADD         reduce using rule 65 (variable -> ID .)
    +               reduce using rule 65 (variable -> ID .)
    =               reduce using rule 65 (variable -> ID .)
    )               reduce using rule 65 (variable -> ID .)
    LTE             reduce using rule 65 (variable -> ID .)
    GTE             reduce using rule 65 (variable -> ID .)
    NEQ             reduce using rule 65 (variable -> ID .)
    EQ              reduce using rule 65 (variable -> ID .)
    <               reduce using rule 65 (variable -> ID .)
    >               reduce using rule 65 (variable -> ID .)
    :               reduce using rule 65 (variable -> ID .)
    {               reduce using rule 65 (variable -> ID .)
    PRINT           reduce using rule 65 (variable -> ID .)
    RETURN          reduce using rule 65 (variable -> ID .)
    CONTINUE        reduce using rule 65 (variable -> ID .)
    BREAK           reduce using rule 65 (variable -> ID .)
    FOR             reduce using rule 65 (variable -> ID .)
    WHILE           reduce using rule 65 (variable -> ID .)
    IF              reduce using rule 65 (variable -> ID .)
    ID              reduce using rule 65 (variable -> ID .)


state 30

    (53) expr -> number .
    DOT_DIV         reduce using rule 53 (expr -> number .)
    /               reduce using rule 53 (expr -> number .)
    DOT_MUL         reduce using rule 53 (expr -> number .)
    *               reduce using rule 53 (expr -> number .)
    DOT_SUB         reduce using rule 53 (expr -> number .)
    -               reduce using rule 53 (expr -> number .)
    DOT_ADD         reduce using rule 53 (expr -> number .)
    +               reduce using rule 53 (expr -> number .)
    ;               reduce using rule 53 (expr -> number .)
    ,               reduce using rule 53 (expr -> number .)
    )               reduce using rule 53 (expr -> number .)
    LTE             reduce using rule 53 (expr -> number .)
    GTE             reduce using rule 53 (expr -> number .)
    NEQ             reduce using rule 53 (expr -> number .)
    EQ              reduce using rule 53 (expr -> number .)
    <               reduce using rule 53 (expr -> number .)
    >               reduce using rule 53 (expr -> number .)
    :               reduce using rule 53 (expr -> number .)
    {               reduce using rule 53 (expr -> number .)
    PRINT           reduce using rule 53 (expr -> number .)
    RETURN          reduce using rule 53 (expr -> number .)
    CONTINUE        reduce using rule 53 (expr -> number .)
    BREAK           reduce using rule 53 (expr -> number .)
    FOR             reduce using rule 53 (expr -> number .)
    WHILE           reduce using rule 53 (expr -> number .)
    IF              reduce using rule 53 (expr -> number .)
    ID              reduce using rule 53 (expr -> number .)


state 31

    (54) expr -> matrix .
    (38) matrix -> matrix . '
    DOT_DIV         reduce using rule 54 (expr -> matrix .)
    /               reduce using rule 54 (expr -> matrix .)
    DOT_MUL         reduce using rule 54 (expr -> matrix .)
    *               reduce using rule 54 (expr -> matrix .)
    DOT_SUB         reduce using rule 54 (expr -> matrix .)
    -               reduce using rule 54 (expr -> matrix .)
    DOT_ADD         reduce using rule 54 (expr -> matrix .)
    +               reduce using rule 54 (expr -> matrix .)
    ;               reduce using rule 54 (expr -> matrix .)
    ,               reduce using rule 54 (expr -> matrix .)
    )               reduce using rule 54 (expr -> matrix .)
    LTE             reduce using rule 54 (expr -> matrix .)
    GTE             reduce using rule 54 (expr -> matrix .)
    NEQ             reduce using rule 54 (expr -> matrix .)
    EQ              reduce using rule 54 (expr -> matrix .)
    <               reduce using rule 54 (expr -> matrix .)
    >               reduce using rule 54 (expr -> matrix .)
    :               reduce using rule 54 (expr -> matrix .)
    {               reduce using rule 54 (expr -> matrix .)
    PRINT           reduce using rule 54 (expr -> matrix .)
    RETURN          reduce using rule 54 (expr -> matrix .)
    CONTINUE        reduce using rule 54 (expr -> matrix .)
    BREAK           reduce using rule 54 (expr -> matrix .)
    FOR             reduce using rule 54 (expr -> matrix .)
    WHILE           reduce using rule 54 (expr -> matrix .)
    IF              reduce using rule 54 (expr -> matrix .)
    ID              reduce using rule 54 (expr -> matrix .)
    '               shift and go to state 75


state 32

    (55) expr -> ( . expr )
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 76
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 33

    (64) expr -> - . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 78
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 34

    (49) number -> FLOATNUM .
    DOT_DIV         reduce using rule 49 (number -> FLOATNUM .)
    /               reduce using rule 49 (number -> FLOATNUM .)
    DOT_MUL         reduce using rule 49 (number -> FLOATNUM .)
    *               reduce using rule 49 (number -> FLOATNUM .)
    DOT_SUB         reduce using rule 49 (number -> FLOATNUM .)
    -               reduce using rule 49 (number -> FLOATNUM .)
    DOT_ADD         reduce using rule 49 (number -> FLOATNUM .)
    +               reduce using rule 49 (number -> FLOATNUM .)
    ;               reduce using rule 49 (number -> FLOATNUM .)
    ,               reduce using rule 49 (number -> FLOATNUM .)
    )               reduce using rule 49 (number -> FLOATNUM .)
    LTE             reduce using rule 49 (number -> FLOATNUM .)
    GTE             reduce using rule 49 (number -> FLOATNUM .)
    NEQ             reduce using rule 49 (number -> FLOATNUM .)
    EQ              reduce using rule 49 (number -> FLOATNUM .)
    <               reduce using rule 49 (number -> FLOATNUM .)
    >               reduce using rule 49 (number -> FLOATNUM .)
    :               reduce using rule 49 (number -> FLOATNUM .)
    {               reduce using rule 49 (number -> FLOATNUM .)
    PRINT           reduce using rule 49 (number -> FLOATNUM .)
    RETURN          reduce using rule 49 (number -> FLOATNUM .)
    CONTINUE        reduce using rule 49 (number -> FLOATNUM .)
    BREAK           reduce using rule 49 (number -> FLOATNUM .)
    FOR             reduce using rule 49 (number -> FLOATNUM .)
    WHILE           reduce using rule 49 (number -> FLOATNUM .)
    IF              reduce using rule 49 (number -> FLOATNUM .)
    ID              reduce using rule 49 (number -> FLOATNUM .)
    ]               reduce using rule 49 (number -> FLOATNUM .)


state 35

    (50) number -> INTNUM .
    DOT_DIV         reduce using rule 50 (number -> INTNUM .)
    /               reduce using rule 50 (number -> INTNUM .)
    DOT_MUL         reduce using rule 50 (number -> INTNUM .)
    *               reduce using rule 50 (number -> INTNUM .)
    DOT_SUB         reduce using rule 50 (number -> INTNUM .)
    -               reduce using rule 50 (number -> INTNUM .)
    DOT_ADD         reduce using rule 50 (number -> INTNUM .)
    +               reduce using rule 50 (number -> INTNUM .)
    ;               reduce using rule 50 (number -> INTNUM .)
    ,               reduce using rule 50 (number -> INTNUM .)
    )               reduce using rule 50 (number -> INTNUM .)
    LTE             reduce using rule 50 (number -> INTNUM .)
    GTE             reduce using rule 50 (number -> INTNUM .)
    NEQ             reduce using rule 50 (number -> INTNUM .)
    EQ              reduce using rule 50 (number -> INTNUM .)
    <               reduce using rule 50 (number -> INTNUM .)
    >               reduce using rule 50 (number -> INTNUM .)
    :               reduce using rule 50 (number -> INTNUM .)
    {               reduce using rule 50 (number -> INTNUM .)
    PRINT           reduce using rule 50 (number -> INTNUM .)
    RETURN          reduce using rule 50 (number -> INTNUM .)
    CONTINUE        reduce using rule 50 (number -> INTNUM .)
    BREAK           reduce using rule 50 (number -> INTNUM .)
    FOR             reduce using rule 50 (number -> INTNUM .)
    WHILE           reduce using rule 50 (number -> INTNUM .)
    IF              reduce using rule 50 (number -> INTNUM .)
    ID              reduce using rule 50 (number -> INTNUM .)
    ]               reduce using rule 50 (number -> INTNUM .)


state 36

    (32) matrix -> EYE . ( INTNUM )
    (               shift and go to state 79


state 37

    (33) matrix -> ONES . ( INTNUM )
    (               shift and go to state 80


state 38

    (34) matrix -> ZEROS . ( INTNUM )
    (               shift and go to state 81


state 39

    (35) matrix -> matrix2 .
    '               reduce using rule 35 (matrix -> matrix2 .)
    DOT_DIV         reduce using rule 35 (matrix -> matrix2 .)
    /               reduce using rule 35 (matrix -> matrix2 .)
    DOT_MUL         reduce using rule 35 (matrix -> matrix2 .)
    *               reduce using rule 35 (matrix -> matrix2 .)
    DOT_SUB         reduce using rule 35 (matrix -> matrix2 .)
    -               reduce using rule 35 (matrix -> matrix2 .)
    DOT_ADD         reduce using rule 35 (matrix -> matrix2 .)
    +               reduce using rule 35 (matrix -> matrix2 .)
    ;               reduce using rule 35 (matrix -> matrix2 .)
    ,               reduce using rule 35 (matrix -> matrix2 .)
    )               reduce using rule 35 (matrix -> matrix2 .)
    LTE             reduce using rule 35 (matrix -> matrix2 .)
    GTE             reduce using rule 35 (matrix -> matrix2 .)
    NEQ             reduce using rule 35 (matrix -> matrix2 .)
    EQ              reduce using rule 35 (matrix -> matrix2 .)
    <               reduce using rule 35 (matrix -> matrix2 .)
    >               reduce using rule 35 (matrix -> matrix2 .)
    :               reduce using rule 35 (matrix -> matrix2 .)
    {               reduce using rule 35 (matrix -> matrix2 .)
    PRINT           reduce using rule 35 (matrix -> matrix2 .)
    RETURN          reduce using rule 35 (matrix -> matrix2 .)
    CONTINUE        reduce using rule 35 (matrix -> matrix2 .)
    BREAK           reduce using rule 35 (matrix -> matrix2 .)
    FOR             reduce using rule 35 (matrix -> matrix2 .)
    WHILE           reduce using rule 35 (matrix -> matrix2 .)
    IF              reduce using rule 35 (matrix -> matrix2 .)
    ID              reduce using rule 35 (matrix -> matrix2 .)


state 40

    (36) matrix -> matrix1 .
    '               reduce using rule 36 (matrix -> matrix1 .)
    DOT_DIV         reduce using rule 36 (matrix -> matrix1 .)
    /               reduce using rule 36 (matrix -> matrix1 .)
    DOT_MUL         reduce using rule 36 (matrix -> matrix1 .)
    *               reduce using rule 36 (matrix -> matrix1 .)
    DOT_SUB         reduce using rule 36 (matrix -> matrix1 .)
    -               reduce using rule 36 (matrix -> matrix1 .)
    DOT_ADD         reduce using rule 36 (matrix -> matrix1 .)
    +               reduce using rule 36 (matrix -> matrix1 .)
    ;               reduce using rule 36 (matrix -> matrix1 .)
    ,               reduce using rule 36 (matrix -> matrix1 .)
    )               reduce using rule 36 (matrix -> matrix1 .)
    LTE             reduce using rule 36 (matrix -> matrix1 .)
    GTE             reduce using rule 36 (matrix -> matrix1 .)
    NEQ             reduce using rule 36 (matrix -> matrix1 .)
    EQ              reduce using rule 36 (matrix -> matrix1 .)
    <               reduce using rule 36 (matrix -> matrix1 .)
    >               reduce using rule 36 (matrix -> matrix1 .)
    :               reduce using rule 36 (matrix -> matrix1 .)
    {               reduce using rule 36 (matrix -> matrix1 .)
    PRINT           reduce using rule 36 (matrix -> matrix1 .)
    RETURN          reduce using rule 36 (matrix -> matrix1 .)
    CONTINUE        reduce using rule 36 (matrix -> matrix1 .)
    BREAK           reduce using rule 36 (matrix -> matrix1 .)
    FOR             reduce using rule 36 (matrix -> matrix1 .)
    WHILE           reduce using rule 36 (matrix -> matrix1 .)
    IF              reduce using rule 36 (matrix -> matrix1 .)
    ID              reduce using rule 36 (matrix -> matrix1 .)


state 41

    (37) matrix -> [ . ]
    (44) matrix2 -> [ . rows2 ]
    (41) matrix1 -> [ . rows1 ]
    (45) rows2 -> . [ row ]
    (46) rows2 -> . rows2 , [ row ]
    (42) rows1 -> . row
    (43) rows1 -> . rows1 ; row
    (47) row -> . number
    (48) row -> . row , number
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    ]               shift and go to state 83
    [               shift and go to state 82
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35

    rows2                          shift and go to state 84
    rows1                          shift and go to state 85
    row                            shift and go to state 86
    number                         shift and go to state 87

state 42

    (8) line -> matrix_assign ; .
    PRINT           reduce using rule 8 (line -> matrix_assign ; .)
    RETURN          reduce using rule 8 (line -> matrix_assign ; .)
    CONTINUE        reduce using rule 8 (line -> matrix_assign ; .)
    BREAK           reduce using rule 8 (line -> matrix_assign ; .)
    FOR             reduce using rule 8 (line -> matrix_assign ; .)
    WHILE           reduce using rule 8 (line -> matrix_assign ; .)
    IF              reduce using rule 8 (line -> matrix_assign ; .)
    ID              reduce using rule 8 (line -> matrix_assign ; .)
    $end            reduce using rule 8 (line -> matrix_assign ; .)
    ELSE            reduce using rule 8 (line -> matrix_assign ; .)
    }               reduce using rule 8 (line -> matrix_assign ; .)


state 43

    (9) line -> div_assign ; .
    PRINT           reduce using rule 9 (line -> div_assign ; .)
    RETURN          reduce using rule 9 (line -> div_assign ; .)
    CONTINUE        reduce using rule 9 (line -> div_assign ; .)
    BREAK           reduce using rule 9 (line -> div_assign ; .)
    FOR             reduce using rule 9 (line -> div_assign ; .)
    WHILE           reduce using rule 9 (line -> div_assign ; .)
    IF              reduce using rule 9 (line -> div_assign ; .)
    ID              reduce using rule 9 (line -> div_assign ; .)
    $end            reduce using rule 9 (line -> div_assign ; .)
    ELSE            reduce using rule 9 (line -> div_assign ; .)
    }               reduce using rule 9 (line -> div_assign ; .)


state 44

    (10) line -> mul_assign ; .
    PRINT           reduce using rule 10 (line -> mul_assign ; .)
    RETURN          reduce using rule 10 (line -> mul_assign ; .)
    CONTINUE        reduce using rule 10 (line -> mul_assign ; .)
    BREAK           reduce using rule 10 (line -> mul_assign ; .)
    FOR             reduce using rule 10 (line -> mul_assign ; .)
    WHILE           reduce using rule 10 (line -> mul_assign ; .)
    IF              reduce using rule 10 (line -> mul_assign ; .)
    ID              reduce using rule 10 (line -> mul_assign ; .)
    $end            reduce using rule 10 (line -> mul_assign ; .)
    ELSE            reduce using rule 10 (line -> mul_assign ; .)
    }               reduce using rule 10 (line -> mul_assign ; .)


state 45

    (11) line -> sub_assign ; .
    PRINT           reduce using rule 11 (line -> sub_assign ; .)
    RETURN          reduce using rule 11 (line -> sub_assign ; .)
    CONTINUE        reduce using rule 11 (line -> sub_assign ; .)
    BREAK           reduce using rule 11 (line -> sub_assign ; .)
    FOR             reduce using rule 11 (line -> sub_assign ; .)
    WHILE           reduce using rule 11 (line -> sub_assign ; .)
    IF              reduce using rule 11 (line -> sub_assign ; .)
    ID              reduce using rule 11 (line -> sub_assign ; .)
    $end            reduce using rule 11 (line -> sub_assign ; .)
    ELSE            reduce using rule 11 (line -> sub_assign ; .)
    }               reduce using rule 11 (line -> sub_assign ; .)


state 46

    (12) line -> add_assign ; .
    PRINT           reduce using rule 12 (line -> add_assign ; .)
    RETURN          reduce using rule 12 (line -> add_assign ; .)
    CONTINUE        reduce using rule 12 (line -> add_assign ; .)
    BREAK           reduce using rule 12 (line -> add_assign ; .)
    FOR             reduce using rule 12 (line -> add_assign ; .)
    WHILE           reduce using rule 12 (line -> add_assign ; .)
    IF              reduce using rule 12 (line -> add_assign ; .)
    ID              reduce using rule 12 (line -> add_assign ; .)
    $end            reduce using rule 12 (line -> add_assign ; .)
    ELSE            reduce using rule 12 (line -> add_assign ; .)
    }               reduce using rule 12 (line -> add_assign ; .)


state 47

    (13) line -> RETURN statement_values . ;
    (74) statement_values -> statement_values . , statement_value
    ;               shift and go to state 88
    ,               shift and go to state 65


state 48

    (14) line -> CONTINUE ; .
    PRINT           reduce using rule 14 (line -> CONTINUE ; .)
    RETURN          reduce using rule 14 (line -> CONTINUE ; .)
    CONTINUE        reduce using rule 14 (line -> CONTINUE ; .)
    BREAK           reduce using rule 14 (line -> CONTINUE ; .)
    FOR             reduce using rule 14 (line -> CONTINUE ; .)
    WHILE           reduce using rule 14 (line -> CONTINUE ; .)
    IF              reduce using rule 14 (line -> CONTINUE ; .)
    ID              reduce using rule 14 (line -> CONTINUE ; .)
    $end            reduce using rule 14 (line -> CONTINUE ; .)
    ELSE            reduce using rule 14 (line -> CONTINUE ; .)
    }               reduce using rule 14 (line -> CONTINUE ; .)


state 49

    (15) line -> BREAK ; .
    PRINT           reduce using rule 15 (line -> BREAK ; .)
    RETURN          reduce using rule 15 (line -> BREAK ; .)
    CONTINUE        reduce using rule 15 (line -> BREAK ; .)
    BREAK           reduce using rule 15 (line -> BREAK ; .)
    FOR             reduce using rule 15 (line -> BREAK ; .)
    WHILE           reduce using rule 15 (line -> BREAK ; .)
    IF              reduce using rule 15 (line -> BREAK ; .)
    ID              reduce using rule 15 (line -> BREAK ; .)
    $end            reduce using rule 15 (line -> BREAK ; .)
    ELSE            reduce using rule 15 (line -> BREAK ; .)
    }               reduce using rule 15 (line -> BREAK ; .)


state 50

    (16) line -> assign ; .
    PRINT           reduce using rule 16 (line -> assign ; .)
    RETURN          reduce using rule 16 (line -> assign ; .)
    CONTINUE        reduce using rule 16 (line -> assign ; .)
    BREAK           reduce using rule 16 (line -> assign ; .)
    FOR             reduce using rule 16 (line -> assign ; .)
    WHILE           reduce using rule 16 (line -> assign ; .)
    IF              reduce using rule 16 (line -> assign ; .)
    ID              reduce using rule 16 (line -> assign ; .)
    $end            reduce using rule 16 (line -> assign ; .)
    ELSE            reduce using rule 16 (line -> assign ; .)
    }               reduce using rule 16 (line -> assign ; .)


state 51

    (23) for_statement -> FOR variable . = expr : expr block
    =               shift and go to state 89


state 52

    (29) div_assign -> variable DIV_ASSIGN . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    variable                       shift and go to state 77
    expr                           shift and go to state 90
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 53

    (28) mul_assign -> variable MUL_ASSIGN . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    variable                       shift and go to state 77
    expr                           shift and go to state 91
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 54

    (27) sub_assign -> variable SUB_ASSIGN . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    variable                       shift and go to state 77
    expr                           shift and go to state 92
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 55

    (26) add_assign -> variable ADD_ASSIGN . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    variable                       shift and go to state 77
    expr                           shift and go to state 93
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 56

    (24) assign -> variable = . STRING
    (25) assign -> variable = . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    STRING          shift and go to state 94
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    variable                       shift and go to state 77
    expr                           shift and go to state 95
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 57

    (22) while_statement -> WHILE ( . relative ) block
    (72) relative -> . expr rel_op expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    relative                       shift and go to state 96
    expr                           shift and go to state 97
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 58

    (21) if_statement -> IF ( . relative ) block
    (72) relative -> . expr rel_op expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    relative                       shift and go to state 98
    expr                           shift and go to state 97
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 59

    (30) matrix_assign -> ID [ . index ] = expr
    (31) matrix_assign -> ID [ . indexes ] = expr
    (40) index -> . INTNUM
    (39) indexes -> . INTNUM , INTNUM
    INTNUM          shift and go to state 101

    index                          shift and go to state 99
    indexes                        shift and go to state 100

state 60

    (19) if_statement -> if_statement ELSE if_statement .
    (19) if_statement -> if_statement . ELSE if_statement
    (20) if_statement -> if_statement . ELSE block
    (6) line -> if_statement .
  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 6 (line -> if_statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 6 (line -> if_statement .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 6 (line -> if_statement .)
  ! reduce/reduce conflict for BREAK resolved using rule 6 (line -> if_statement .)
  ! reduce/reduce conflict for FOR resolved using rule 6 (line -> if_statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 6 (line -> if_statement .)
  ! reduce/reduce conflict for IF resolved using rule 6 (line -> if_statement .)
  ! reduce/reduce conflict for ID resolved using rule 6 (line -> if_statement .)
  ! reduce/reduce conflict for $end resolved using rule 6 (line -> if_statement .)
  ! reduce/reduce conflict for } resolved using rule 6 (line -> if_statement .)
    ELSE            shift and go to state 23
    PRINT           reduce using rule 6 (line -> if_statement .)
    RETURN          reduce using rule 6 (line -> if_statement .)
    CONTINUE        reduce using rule 6 (line -> if_statement .)
    BREAK           reduce using rule 6 (line -> if_statement .)
    FOR             reduce using rule 6 (line -> if_statement .)
    WHILE           reduce using rule 6 (line -> if_statement .)
    IF              reduce using rule 6 (line -> if_statement .)
    ID              reduce using rule 6 (line -> if_statement .)
    $end            reduce using rule 6 (line -> if_statement .)
    }               reduce using rule 6 (line -> if_statement .)


state 61

    (20) if_statement -> if_statement ELSE block .
    ELSE            reduce using rule 20 (if_statement -> if_statement ELSE block .)
    PRINT           reduce using rule 20 (if_statement -> if_statement ELSE block .)
    RETURN          reduce using rule 20 (if_statement -> if_statement ELSE block .)
    CONTINUE        reduce using rule 20 (if_statement -> if_statement ELSE block .)
    BREAK           reduce using rule 20 (if_statement -> if_statement ELSE block .)
    FOR             reduce using rule 20 (if_statement -> if_statement ELSE block .)
    WHILE           reduce using rule 20 (if_statement -> if_statement ELSE block .)
    IF              reduce using rule 20 (if_statement -> if_statement ELSE block .)
    ID              reduce using rule 20 (if_statement -> if_statement ELSE block .)
    $end            reduce using rule 20 (if_statement -> if_statement ELSE block .)
    }               reduce using rule 20 (if_statement -> if_statement ELSE block .)


state 62

    (17) block -> { . lines }
    (2) lines -> . line
    (3) lines -> . lines line
    (4) line -> . for_statement
    (5) line -> . while_statement
    (6) line -> . if_statement
    (7) line -> . PRINT statement_values ;
    (8) line -> . matrix_assign ;
    (9) line -> . div_assign ;
    (10) line -> . mul_assign ;
    (11) line -> . sub_assign ;
    (12) line -> . add_assign ;
    (13) line -> . RETURN statement_values ;
    (14) line -> . CONTINUE ;
    (15) line -> . BREAK ;
    (16) line -> . assign ;
    (23) for_statement -> . FOR variable = expr : expr block
    (22) while_statement -> . WHILE ( relative ) block
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE block
    (21) if_statement -> . IF ( relative ) block
    (30) matrix_assign -> . ID [ index ] = expr
    (31) matrix_assign -> . ID [ indexes ] = expr
    (29) div_assign -> . variable DIV_ASSIGN expr
    (28) mul_assign -> . variable MUL_ASSIGN expr
    (27) sub_assign -> . variable SUB_ASSIGN expr
    (26) add_assign -> . variable ADD_ASSIGN expr
    (24) assign -> . variable = STRING
    (25) assign -> . variable = expr
    (65) variable -> . ID
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 21

    lines                          shift and go to state 102
    line                           shift and go to state 3
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    matrix_assign                  shift and go to state 8
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16
    variable                       shift and go to state 18

state 63

    (18) block -> line .
    ELSE            reduce using rule 18 (block -> line .)
    PRINT           reduce using rule 18 (block -> line .)
    RETURN          reduce using rule 18 (block -> line .)
    CONTINUE        reduce using rule 18 (block -> line .)
    BREAK           reduce using rule 18 (block -> line .)
    FOR             reduce using rule 18 (block -> line .)
    WHILE           reduce using rule 18 (block -> line .)
    IF              reduce using rule 18 (block -> line .)
    ID              reduce using rule 18 (block -> line .)
    $end            reduce using rule 18 (block -> line .)
    }               reduce using rule 18 (block -> line .)


state 64

    (7) line -> PRINT statement_values ; .
    PRINT           reduce using rule 7 (line -> PRINT statement_values ; .)
    RETURN          reduce using rule 7 (line -> PRINT statement_values ; .)
    CONTINUE        reduce using rule 7 (line -> PRINT statement_values ; .)
    BREAK           reduce using rule 7 (line -> PRINT statement_values ; .)
    FOR             reduce using rule 7 (line -> PRINT statement_values ; .)
    WHILE           reduce using rule 7 (line -> PRINT statement_values ; .)
    IF              reduce using rule 7 (line -> PRINT statement_values ; .)
    ID              reduce using rule 7 (line -> PRINT statement_values ; .)
    $end            reduce using rule 7 (line -> PRINT statement_values ; .)
    ELSE            reduce using rule 7 (line -> PRINT statement_values ; .)
    }               reduce using rule 7 (line -> PRINT statement_values ; .)


state 65

    (74) statement_values -> statement_values , . statement_value
    (75) statement_value -> . variable
    (76) statement_value -> . expr
    (77) statement_value -> . STRING
    (65) variable -> . ID
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    STRING          shift and go to state 28
    ID              shift and go to state 29
    (               shift and go to state 32
    -               shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    statement_value                shift and go to state 103
    variable                       shift and go to state 26
    expr                           shift and go to state 27
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 66

    (52) expr -> variable ' .
    DOT_DIV         reduce using rule 52 (expr -> variable ' .)
    /               reduce using rule 52 (expr -> variable ' .)
    DOT_MUL         reduce using rule 52 (expr -> variable ' .)
    *               reduce using rule 52 (expr -> variable ' .)
    DOT_SUB         reduce using rule 52 (expr -> variable ' .)
    -               reduce using rule 52 (expr -> variable ' .)
    DOT_ADD         reduce using rule 52 (expr -> variable ' .)
    +               reduce using rule 52 (expr -> variable ' .)
    ;               reduce using rule 52 (expr -> variable ' .)
    ,               reduce using rule 52 (expr -> variable ' .)
    )               reduce using rule 52 (expr -> variable ' .)
    LTE             reduce using rule 52 (expr -> variable ' .)
    GTE             reduce using rule 52 (expr -> variable ' .)
    NEQ             reduce using rule 52 (expr -> variable ' .)
    EQ              reduce using rule 52 (expr -> variable ' .)
    <               reduce using rule 52 (expr -> variable ' .)
    >               reduce using rule 52 (expr -> variable ' .)
    :               reduce using rule 52 (expr -> variable ' .)
    {               reduce using rule 52 (expr -> variable ' .)
    PRINT           reduce using rule 52 (expr -> variable ' .)
    RETURN          reduce using rule 52 (expr -> variable ' .)
    CONTINUE        reduce using rule 52 (expr -> variable ' .)
    BREAK           reduce using rule 52 (expr -> variable ' .)
    FOR             reduce using rule 52 (expr -> variable ' .)
    WHILE           reduce using rule 52 (expr -> variable ' .)
    IF              reduce using rule 52 (expr -> variable ' .)
    ID              reduce using rule 52 (expr -> variable ' .)


state 67

    (56) expr -> expr DOT_DIV . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 104
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 68

    (57) expr -> expr / . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 105
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 69

    (58) expr -> expr DOT_MUL . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 106
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 70

    (59) expr -> expr * . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 107
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 71

    (60) expr -> expr DOT_SUB . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 108
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 72

    (61) expr -> expr - . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 109
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 73

    (62) expr -> expr DOT_ADD . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 110
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 74

    (63) expr -> expr + . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 111
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 75

    (38) matrix -> matrix ' .
    '               reduce using rule 38 (matrix -> matrix ' .)
    DOT_DIV         reduce using rule 38 (matrix -> matrix ' .)
    /               reduce using rule 38 (matrix -> matrix ' .)
    DOT_MUL         reduce using rule 38 (matrix -> matrix ' .)
    *               reduce using rule 38 (matrix -> matrix ' .)
    DOT_SUB         reduce using rule 38 (matrix -> matrix ' .)
    -               reduce using rule 38 (matrix -> matrix ' .)
    DOT_ADD         reduce using rule 38 (matrix -> matrix ' .)
    +               reduce using rule 38 (matrix -> matrix ' .)
    ;               reduce using rule 38 (matrix -> matrix ' .)
    ,               reduce using rule 38 (matrix -> matrix ' .)
    )               reduce using rule 38 (matrix -> matrix ' .)
    LTE             reduce using rule 38 (matrix -> matrix ' .)
    GTE             reduce using rule 38 (matrix -> matrix ' .)
    NEQ             reduce using rule 38 (matrix -> matrix ' .)
    EQ              reduce using rule 38 (matrix -> matrix ' .)
    <               reduce using rule 38 (matrix -> matrix ' .)
    >               reduce using rule 38 (matrix -> matrix ' .)
    :               reduce using rule 38 (matrix -> matrix ' .)
    {               reduce using rule 38 (matrix -> matrix ' .)
    PRINT           reduce using rule 38 (matrix -> matrix ' .)
    RETURN          reduce using rule 38 (matrix -> matrix ' .)
    CONTINUE        reduce using rule 38 (matrix -> matrix ' .)
    BREAK           reduce using rule 38 (matrix -> matrix ' .)
    FOR             reduce using rule 38 (matrix -> matrix ' .)
    WHILE           reduce using rule 38 (matrix -> matrix ' .)
    IF              reduce using rule 38 (matrix -> matrix ' .)
    ID              reduce using rule 38 (matrix -> matrix ' .)


state 76

    (55) expr -> ( expr . )
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    )               shift and go to state 112
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 77

    (51) expr -> variable .
    (52) expr -> variable . '
    )               reduce using rule 51 (expr -> variable .)
    DOT_DIV         reduce using rule 51 (expr -> variable .)
    /               reduce using rule 51 (expr -> variable .)
    DOT_MUL         reduce using rule 51 (expr -> variable .)
    *               reduce using rule 51 (expr -> variable .)
    DOT_SUB         reduce using rule 51 (expr -> variable .)
    -               reduce using rule 51 (expr -> variable .)
    DOT_ADD         reduce using rule 51 (expr -> variable .)
    +               reduce using rule 51 (expr -> variable .)
    ;               reduce using rule 51 (expr -> variable .)
    ,               reduce using rule 51 (expr -> variable .)
    LTE             reduce using rule 51 (expr -> variable .)
    GTE             reduce using rule 51 (expr -> variable .)
    NEQ             reduce using rule 51 (expr -> variable .)
    EQ              reduce using rule 51 (expr -> variable .)
    <               reduce using rule 51 (expr -> variable .)
    >               reduce using rule 51 (expr -> variable .)
    :               reduce using rule 51 (expr -> variable .)
    {               reduce using rule 51 (expr -> variable .)
    PRINT           reduce using rule 51 (expr -> variable .)
    RETURN          reduce using rule 51 (expr -> variable .)
    CONTINUE        reduce using rule 51 (expr -> variable .)
    BREAK           reduce using rule 51 (expr -> variable .)
    FOR             reduce using rule 51 (expr -> variable .)
    WHILE           reduce using rule 51 (expr -> variable .)
    IF              reduce using rule 51 (expr -> variable .)
    ID              reduce using rule 51 (expr -> variable .)
    '               shift and go to state 66


state 78

    (64) expr -> - expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    DOT_DIV         reduce using rule 64 (expr -> - expr .)
    /               reduce using rule 64 (expr -> - expr .)
    DOT_MUL         reduce using rule 64 (expr -> - expr .)
    *               reduce using rule 64 (expr -> - expr .)
    DOT_SUB         reduce using rule 64 (expr -> - expr .)
    -               reduce using rule 64 (expr -> - expr .)
    DOT_ADD         reduce using rule 64 (expr -> - expr .)
    +               reduce using rule 64 (expr -> - expr .)
    ;               reduce using rule 64 (expr -> - expr .)
    ,               reduce using rule 64 (expr -> - expr .)
    )               reduce using rule 64 (expr -> - expr .)
    LTE             reduce using rule 64 (expr -> - expr .)
    GTE             reduce using rule 64 (expr -> - expr .)
    NEQ             reduce using rule 64 (expr -> - expr .)
    EQ              reduce using rule 64 (expr -> - expr .)
    <               reduce using rule 64 (expr -> - expr .)
    >               reduce using rule 64 (expr -> - expr .)
    :               reduce using rule 64 (expr -> - expr .)
    {               reduce using rule 64 (expr -> - expr .)
    PRINT           reduce using rule 64 (expr -> - expr .)
    RETURN          reduce using rule 64 (expr -> - expr .)
    CONTINUE        reduce using rule 64 (expr -> - expr .)
    BREAK           reduce using rule 64 (expr -> - expr .)
    FOR             reduce using rule 64 (expr -> - expr .)
    WHILE           reduce using rule 64 (expr -> - expr .)
    IF              reduce using rule 64 (expr -> - expr .)
    ID              reduce using rule 64 (expr -> - expr .)


state 79

    (32) matrix -> EYE ( . INTNUM )
    INTNUM          shift and go to state 113


state 80

    (33) matrix -> ONES ( . INTNUM )
    INTNUM          shift and go to state 114


state 81

    (34) matrix -> ZEROS ( . INTNUM )
    INTNUM          shift and go to state 115


state 82

    (45) rows2 -> [ . row ]
    (47) row -> . number
    (48) row -> . row , number
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35

    row                            shift and go to state 116
    number                         shift and go to state 87

state 83

    (37) matrix -> [ ] .
    '               reduce using rule 37 (matrix -> [ ] .)
    DOT_DIV         reduce using rule 37 (matrix -> [ ] .)
    /               reduce using rule 37 (matrix -> [ ] .)
    DOT_MUL         reduce using rule 37 (matrix -> [ ] .)
    *               reduce using rule 37 (matrix -> [ ] .)
    DOT_SUB         reduce using rule 37 (matrix -> [ ] .)
    -               reduce using rule 37 (matrix -> [ ] .)
    DOT_ADD         reduce using rule 37 (matrix -> [ ] .)
    +               reduce using rule 37 (matrix -> [ ] .)
    ;               reduce using rule 37 (matrix -> [ ] .)
    ,               reduce using rule 37 (matrix -> [ ] .)
    )               reduce using rule 37 (matrix -> [ ] .)
    LTE             reduce using rule 37 (matrix -> [ ] .)
    GTE             reduce using rule 37 (matrix -> [ ] .)
    NEQ             reduce using rule 37 (matrix -> [ ] .)
    EQ              reduce using rule 37 (matrix -> [ ] .)
    <               reduce using rule 37 (matrix -> [ ] .)
    >               reduce using rule 37 (matrix -> [ ] .)
    :               reduce using rule 37 (matrix -> [ ] .)
    {               reduce using rule 37 (matrix -> [ ] .)
    PRINT           reduce using rule 37 (matrix -> [ ] .)
    RETURN          reduce using rule 37 (matrix -> [ ] .)
    CONTINUE        reduce using rule 37 (matrix -> [ ] .)
    BREAK           reduce using rule 37 (matrix -> [ ] .)
    FOR             reduce using rule 37 (matrix -> [ ] .)
    WHILE           reduce using rule 37 (matrix -> [ ] .)
    IF              reduce using rule 37 (matrix -> [ ] .)
    ID              reduce using rule 37 (matrix -> [ ] .)


state 84

    (44) matrix2 -> [ rows2 . ]
    (46) rows2 -> rows2 . , [ row ]
    ]               shift and go to state 117
    ,               shift and go to state 118


state 85

    (41) matrix1 -> [ rows1 . ]
    (43) rows1 -> rows1 . ; row
    ]               shift and go to state 119
    ;               shift and go to state 120


state 86

    (42) rows1 -> row .
    (48) row -> row . , number
    ]               reduce using rule 42 (rows1 -> row .)
    ;               reduce using rule 42 (rows1 -> row .)
    ,               shift and go to state 121


state 87

    (47) row -> number .
    ,               reduce using rule 47 (row -> number .)
    ]               reduce using rule 47 (row -> number .)
    ;               reduce using rule 47 (row -> number .)


state 88

    (13) line -> RETURN statement_values ; .
    PRINT           reduce using rule 13 (line -> RETURN statement_values ; .)
    RETURN          reduce using rule 13 (line -> RETURN statement_values ; .)
    CONTINUE        reduce using rule 13 (line -> RETURN statement_values ; .)
    BREAK           reduce using rule 13 (line -> RETURN statement_values ; .)
    FOR             reduce using rule 13 (line -> RETURN statement_values ; .)
    WHILE           reduce using rule 13 (line -> RETURN statement_values ; .)
    IF              reduce using rule 13 (line -> RETURN statement_values ; .)
    ID              reduce using rule 13 (line -> RETURN statement_values ; .)
    $end            reduce using rule 13 (line -> RETURN statement_values ; .)
    ELSE            reduce using rule 13 (line -> RETURN statement_values ; .)
    }               reduce using rule 13 (line -> RETURN statement_values ; .)


state 89

    (23) for_statement -> FOR variable = . expr : expr block
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    variable                       shift and go to state 77
    expr                           shift and go to state 122
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 90

    (29) div_assign -> variable DIV_ASSIGN expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    ;               reduce using rule 29 (div_assign -> variable DIV_ASSIGN expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 91

    (28) mul_assign -> variable MUL_ASSIGN expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    ;               reduce using rule 28 (mul_assign -> variable MUL_ASSIGN expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 92

    (27) sub_assign -> variable SUB_ASSIGN expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    ;               reduce using rule 27 (sub_assign -> variable SUB_ASSIGN expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 93

    (26) add_assign -> variable ADD_ASSIGN expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    ;               reduce using rule 26 (add_assign -> variable ADD_ASSIGN expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 94

    (24) assign -> variable = STRING .
    ;               reduce using rule 24 (assign -> variable = STRING .)


state 95

    (25) assign -> variable = expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    ;               reduce using rule 25 (assign -> variable = expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 96

    (22) while_statement -> WHILE ( relative . ) block
    )               shift and go to state 123


state 97

    (72) relative -> expr . rel_op expr
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    (66) rel_op -> . LTE
    (67) rel_op -> . GTE
    (68) rel_op -> . NEQ
    (69) rel_op -> . EQ
    (70) rel_op -> . <
    (71) rel_op -> . >
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74
    LTE             shift and go to state 125
    GTE             shift and go to state 126
    NEQ             shift and go to state 127
    EQ              shift and go to state 128
    <               shift and go to state 129
    >               shift and go to state 130

    rel_op                         shift and go to state 124

state 98

    (21) if_statement -> IF ( relative . ) block
    )               shift and go to state 131


state 99

    (30) matrix_assign -> ID [ index . ] = expr
    ]               shift and go to state 132


state 100

    (31) matrix_assign -> ID [ indexes . ] = expr
    ]               shift and go to state 133


state 101

    (40) index -> INTNUM .
    (39) indexes -> INTNUM . , INTNUM
    ]               reduce using rule 40 (index -> INTNUM .)
    ,               shift and go to state 134


state 102

    (17) block -> { lines . }
    (3) lines -> lines . line
    (4) line -> . for_statement
    (5) line -> . while_statement
    (6) line -> . if_statement
    (7) line -> . PRINT statement_values ;
    (8) line -> . matrix_assign ;
    (9) line -> . div_assign ;
    (10) line -> . mul_assign ;
    (11) line -> . sub_assign ;
    (12) line -> . add_assign ;
    (13) line -> . RETURN statement_values ;
    (14) line -> . CONTINUE ;
    (15) line -> . BREAK ;
    (16) line -> . assign ;
    (23) for_statement -> . FOR variable = expr : expr block
    (22) while_statement -> . WHILE ( relative ) block
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE block
    (21) if_statement -> . IF ( relative ) block
    (30) matrix_assign -> . ID [ index ] = expr
    (31) matrix_assign -> . ID [ indexes ] = expr
    (29) div_assign -> . variable DIV_ASSIGN expr
    (28) mul_assign -> . variable MUL_ASSIGN expr
    (27) sub_assign -> . variable SUB_ASSIGN expr
    (26) add_assign -> . variable ADD_ASSIGN expr
    (24) assign -> . variable = STRING
    (25) assign -> . variable = expr
    (65) variable -> . ID
    }               shift and go to state 135
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 21

    line                           shift and go to state 22
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    matrix_assign                  shift and go to state 8
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16
    variable                       shift and go to state 18

state 103

    (74) statement_values -> statement_values , statement_value .
    ;               reduce using rule 74 (statement_values -> statement_values , statement_value .)
    ,               reduce using rule 74 (statement_values -> statement_values , statement_value .)


state 104

    (56) expr -> expr DOT_DIV expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    DOT_DIV         reduce using rule 56 (expr -> expr DOT_DIV expr .)
    /               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    DOT_MUL         reduce using rule 56 (expr -> expr DOT_DIV expr .)
    *               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    DOT_SUB         reduce using rule 56 (expr -> expr DOT_DIV expr .)
    -               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    DOT_ADD         reduce using rule 56 (expr -> expr DOT_DIV expr .)
    +               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    ;               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    ,               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    )               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    LTE             reduce using rule 56 (expr -> expr DOT_DIV expr .)
    GTE             reduce using rule 56 (expr -> expr DOT_DIV expr .)
    NEQ             reduce using rule 56 (expr -> expr DOT_DIV expr .)
    EQ              reduce using rule 56 (expr -> expr DOT_DIV expr .)
    <               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    >               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    :               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    {               reduce using rule 56 (expr -> expr DOT_DIV expr .)
    PRINT           reduce using rule 56 (expr -> expr DOT_DIV expr .)
    RETURN          reduce using rule 56 (expr -> expr DOT_DIV expr .)
    CONTINUE        reduce using rule 56 (expr -> expr DOT_DIV expr .)
    BREAK           reduce using rule 56 (expr -> expr DOT_DIV expr .)
    FOR             reduce using rule 56 (expr -> expr DOT_DIV expr .)
    WHILE           reduce using rule 56 (expr -> expr DOT_DIV expr .)
    IF              reduce using rule 56 (expr -> expr DOT_DIV expr .)
    ID              reduce using rule 56 (expr -> expr DOT_DIV expr .)


state 105

    (57) expr -> expr / expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    /               reduce using rule 57 (expr -> expr / expr .)
    *               reduce using rule 57 (expr -> expr / expr .)
    -               reduce using rule 57 (expr -> expr / expr .)
    +               reduce using rule 57 (expr -> expr / expr .)
    ;               reduce using rule 57 (expr -> expr / expr .)
    ,               reduce using rule 57 (expr -> expr / expr .)
    )               reduce using rule 57 (expr -> expr / expr .)
    LTE             reduce using rule 57 (expr -> expr / expr .)
    GTE             reduce using rule 57 (expr -> expr / expr .)
    NEQ             reduce using rule 57 (expr -> expr / expr .)
    EQ              reduce using rule 57 (expr -> expr / expr .)
    <               reduce using rule 57 (expr -> expr / expr .)
    >               reduce using rule 57 (expr -> expr / expr .)
    :               reduce using rule 57 (expr -> expr / expr .)
    {               reduce using rule 57 (expr -> expr / expr .)
    PRINT           reduce using rule 57 (expr -> expr / expr .)
    RETURN          reduce using rule 57 (expr -> expr / expr .)
    CONTINUE        reduce using rule 57 (expr -> expr / expr .)
    BREAK           reduce using rule 57 (expr -> expr / expr .)
    FOR             reduce using rule 57 (expr -> expr / expr .)
    WHILE           reduce using rule 57 (expr -> expr / expr .)
    IF              reduce using rule 57 (expr -> expr / expr .)
    ID              reduce using rule 57 (expr -> expr / expr .)
    DOT_DIV         shift and go to state 67
    DOT_MUL         shift and go to state 69
    DOT_SUB         shift and go to state 71
    DOT_ADD         shift and go to state 73


state 106

    (58) expr -> expr DOT_MUL expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    DOT_DIV         reduce using rule 58 (expr -> expr DOT_MUL expr .)
    /               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    DOT_MUL         reduce using rule 58 (expr -> expr DOT_MUL expr .)
    *               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    DOT_SUB         reduce using rule 58 (expr -> expr DOT_MUL expr .)
    -               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    DOT_ADD         reduce using rule 58 (expr -> expr DOT_MUL expr .)
    +               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    ;               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    ,               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    )               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    LTE             reduce using rule 58 (expr -> expr DOT_MUL expr .)
    GTE             reduce using rule 58 (expr -> expr DOT_MUL expr .)
    NEQ             reduce using rule 58 (expr -> expr DOT_MUL expr .)
    EQ              reduce using rule 58 (expr -> expr DOT_MUL expr .)
    <               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    >               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    :               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    {               reduce using rule 58 (expr -> expr DOT_MUL expr .)
    PRINT           reduce using rule 58 (expr -> expr DOT_MUL expr .)
    RETURN          reduce using rule 58 (expr -> expr DOT_MUL expr .)
    CONTINUE        reduce using rule 58 (expr -> expr DOT_MUL expr .)
    BREAK           reduce using rule 58 (expr -> expr DOT_MUL expr .)
    FOR             reduce using rule 58 (expr -> expr DOT_MUL expr .)
    WHILE           reduce using rule 58 (expr -> expr DOT_MUL expr .)
    IF              reduce using rule 58 (expr -> expr DOT_MUL expr .)
    ID              reduce using rule 58 (expr -> expr DOT_MUL expr .)


state 107

    (59) expr -> expr * expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    /               reduce using rule 59 (expr -> expr * expr .)
    *               reduce using rule 59 (expr -> expr * expr .)
    -               reduce using rule 59 (expr -> expr * expr .)
    +               reduce using rule 59 (expr -> expr * expr .)
    ;               reduce using rule 59 (expr -> expr * expr .)
    ,               reduce using rule 59 (expr -> expr * expr .)
    )               reduce using rule 59 (expr -> expr * expr .)
    LTE             reduce using rule 59 (expr -> expr * expr .)
    GTE             reduce using rule 59 (expr -> expr * expr .)
    NEQ             reduce using rule 59 (expr -> expr * expr .)
    EQ              reduce using rule 59 (expr -> expr * expr .)
    <               reduce using rule 59 (expr -> expr * expr .)
    >               reduce using rule 59 (expr -> expr * expr .)
    :               reduce using rule 59 (expr -> expr * expr .)
    {               reduce using rule 59 (expr -> expr * expr .)
    PRINT           reduce using rule 59 (expr -> expr * expr .)
    RETURN          reduce using rule 59 (expr -> expr * expr .)
    CONTINUE        reduce using rule 59 (expr -> expr * expr .)
    BREAK           reduce using rule 59 (expr -> expr * expr .)
    FOR             reduce using rule 59 (expr -> expr * expr .)
    WHILE           reduce using rule 59 (expr -> expr * expr .)
    IF              reduce using rule 59 (expr -> expr * expr .)
    ID              reduce using rule 59 (expr -> expr * expr .)
    DOT_DIV         shift and go to state 67
    DOT_MUL         shift and go to state 69
    DOT_SUB         shift and go to state 71
    DOT_ADD         shift and go to state 73


state 108

    (60) expr -> expr DOT_SUB expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    /               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    *               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    DOT_SUB         reduce using rule 60 (expr -> expr DOT_SUB expr .)
    -               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    DOT_ADD         reduce using rule 60 (expr -> expr DOT_SUB expr .)
    +               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    ;               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    ,               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    )               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    LTE             reduce using rule 60 (expr -> expr DOT_SUB expr .)
    GTE             reduce using rule 60 (expr -> expr DOT_SUB expr .)
    NEQ             reduce using rule 60 (expr -> expr DOT_SUB expr .)
    EQ              reduce using rule 60 (expr -> expr DOT_SUB expr .)
    <               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    >               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    :               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    {               reduce using rule 60 (expr -> expr DOT_SUB expr .)
    PRINT           reduce using rule 60 (expr -> expr DOT_SUB expr .)
    RETURN          reduce using rule 60 (expr -> expr DOT_SUB expr .)
    CONTINUE        reduce using rule 60 (expr -> expr DOT_SUB expr .)
    BREAK           reduce using rule 60 (expr -> expr DOT_SUB expr .)
    FOR             reduce using rule 60 (expr -> expr DOT_SUB expr .)
    WHILE           reduce using rule 60 (expr -> expr DOT_SUB expr .)
    IF              reduce using rule 60 (expr -> expr DOT_SUB expr .)
    ID              reduce using rule 60 (expr -> expr DOT_SUB expr .)
    DOT_DIV         shift and go to state 67
    DOT_MUL         shift and go to state 69


state 109

    (61) expr -> expr - expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    -               reduce using rule 61 (expr -> expr - expr .)
    +               reduce using rule 61 (expr -> expr - expr .)
    ;               reduce using rule 61 (expr -> expr - expr .)
    ,               reduce using rule 61 (expr -> expr - expr .)
    )               reduce using rule 61 (expr -> expr - expr .)
    LTE             reduce using rule 61 (expr -> expr - expr .)
    GTE             reduce using rule 61 (expr -> expr - expr .)
    NEQ             reduce using rule 61 (expr -> expr - expr .)
    EQ              reduce using rule 61 (expr -> expr - expr .)
    <               reduce using rule 61 (expr -> expr - expr .)
    >               reduce using rule 61 (expr -> expr - expr .)
    :               reduce using rule 61 (expr -> expr - expr .)
    {               reduce using rule 61 (expr -> expr - expr .)
    PRINT           reduce using rule 61 (expr -> expr - expr .)
    RETURN          reduce using rule 61 (expr -> expr - expr .)
    CONTINUE        reduce using rule 61 (expr -> expr - expr .)
    BREAK           reduce using rule 61 (expr -> expr - expr .)
    FOR             reduce using rule 61 (expr -> expr - expr .)
    WHILE           reduce using rule 61 (expr -> expr - expr .)
    IF              reduce using rule 61 (expr -> expr - expr .)
    ID              reduce using rule 61 (expr -> expr - expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    DOT_ADD         shift and go to state 73


state 110

    (62) expr -> expr DOT_ADD expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    /               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    *               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    DOT_SUB         reduce using rule 62 (expr -> expr DOT_ADD expr .)
    -               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    DOT_ADD         reduce using rule 62 (expr -> expr DOT_ADD expr .)
    +               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    ;               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    ,               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    )               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    LTE             reduce using rule 62 (expr -> expr DOT_ADD expr .)
    GTE             reduce using rule 62 (expr -> expr DOT_ADD expr .)
    NEQ             reduce using rule 62 (expr -> expr DOT_ADD expr .)
    EQ              reduce using rule 62 (expr -> expr DOT_ADD expr .)
    <               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    >               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    :               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    {               reduce using rule 62 (expr -> expr DOT_ADD expr .)
    PRINT           reduce using rule 62 (expr -> expr DOT_ADD expr .)
    RETURN          reduce using rule 62 (expr -> expr DOT_ADD expr .)
    CONTINUE        reduce using rule 62 (expr -> expr DOT_ADD expr .)
    BREAK           reduce using rule 62 (expr -> expr DOT_ADD expr .)
    FOR             reduce using rule 62 (expr -> expr DOT_ADD expr .)
    WHILE           reduce using rule 62 (expr -> expr DOT_ADD expr .)
    IF              reduce using rule 62 (expr -> expr DOT_ADD expr .)
    ID              reduce using rule 62 (expr -> expr DOT_ADD expr .)
    DOT_DIV         shift and go to state 67
    DOT_MUL         shift and go to state 69


state 111

    (63) expr -> expr + expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    -               reduce using rule 63 (expr -> expr + expr .)
    +               reduce using rule 63 (expr -> expr + expr .)
    ;               reduce using rule 63 (expr -> expr + expr .)
    ,               reduce using rule 63 (expr -> expr + expr .)
    )               reduce using rule 63 (expr -> expr + expr .)
    LTE             reduce using rule 63 (expr -> expr + expr .)
    GTE             reduce using rule 63 (expr -> expr + expr .)
    NEQ             reduce using rule 63 (expr -> expr + expr .)
    EQ              reduce using rule 63 (expr -> expr + expr .)
    <               reduce using rule 63 (expr -> expr + expr .)
    >               reduce using rule 63 (expr -> expr + expr .)
    :               reduce using rule 63 (expr -> expr + expr .)
    {               reduce using rule 63 (expr -> expr + expr .)
    PRINT           reduce using rule 63 (expr -> expr + expr .)
    RETURN          reduce using rule 63 (expr -> expr + expr .)
    CONTINUE        reduce using rule 63 (expr -> expr + expr .)
    BREAK           reduce using rule 63 (expr -> expr + expr .)
    FOR             reduce using rule 63 (expr -> expr + expr .)
    WHILE           reduce using rule 63 (expr -> expr + expr .)
    IF              reduce using rule 63 (expr -> expr + expr .)
    ID              reduce using rule 63 (expr -> expr + expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    DOT_ADD         shift and go to state 73


state 112

    (55) expr -> ( expr ) .
    DOT_DIV         reduce using rule 55 (expr -> ( expr ) .)
    /               reduce using rule 55 (expr -> ( expr ) .)
    DOT_MUL         reduce using rule 55 (expr -> ( expr ) .)
    *               reduce using rule 55 (expr -> ( expr ) .)
    DOT_SUB         reduce using rule 55 (expr -> ( expr ) .)
    -               reduce using rule 55 (expr -> ( expr ) .)
    DOT_ADD         reduce using rule 55 (expr -> ( expr ) .)
    +               reduce using rule 55 (expr -> ( expr ) .)
    ;               reduce using rule 55 (expr -> ( expr ) .)
    ,               reduce using rule 55 (expr -> ( expr ) .)
    )               reduce using rule 55 (expr -> ( expr ) .)
    LTE             reduce using rule 55 (expr -> ( expr ) .)
    GTE             reduce using rule 55 (expr -> ( expr ) .)
    NEQ             reduce using rule 55 (expr -> ( expr ) .)
    EQ              reduce using rule 55 (expr -> ( expr ) .)
    <               reduce using rule 55 (expr -> ( expr ) .)
    >               reduce using rule 55 (expr -> ( expr ) .)
    :               reduce using rule 55 (expr -> ( expr ) .)
    {               reduce using rule 55 (expr -> ( expr ) .)
    PRINT           reduce using rule 55 (expr -> ( expr ) .)
    RETURN          reduce using rule 55 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 55 (expr -> ( expr ) .)
    BREAK           reduce using rule 55 (expr -> ( expr ) .)
    FOR             reduce using rule 55 (expr -> ( expr ) .)
    WHILE           reduce using rule 55 (expr -> ( expr ) .)
    IF              reduce using rule 55 (expr -> ( expr ) .)
    ID              reduce using rule 55 (expr -> ( expr ) .)


state 113

    (32) matrix -> EYE ( INTNUM . )
    )               shift and go to state 136


state 114

    (33) matrix -> ONES ( INTNUM . )
    )               shift and go to state 137


state 115

    (34) matrix -> ZEROS ( INTNUM . )
    )               shift and go to state 138


state 116

    (45) rows2 -> [ row . ]
    (48) row -> row . , number
    ]               shift and go to state 139
    ,               shift and go to state 121


state 117

    (44) matrix2 -> [ rows2 ] .
    '               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    DOT_DIV         reduce using rule 44 (matrix2 -> [ rows2 ] .)
    /               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    DOT_MUL         reduce using rule 44 (matrix2 -> [ rows2 ] .)
    *               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    DOT_SUB         reduce using rule 44 (matrix2 -> [ rows2 ] .)
    -               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    DOT_ADD         reduce using rule 44 (matrix2 -> [ rows2 ] .)
    +               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    ;               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    ,               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    )               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    LTE             reduce using rule 44 (matrix2 -> [ rows2 ] .)
    GTE             reduce using rule 44 (matrix2 -> [ rows2 ] .)
    NEQ             reduce using rule 44 (matrix2 -> [ rows2 ] .)
    EQ              reduce using rule 44 (matrix2 -> [ rows2 ] .)
    <               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    >               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    :               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    {               reduce using rule 44 (matrix2 -> [ rows2 ] .)
    PRINT           reduce using rule 44 (matrix2 -> [ rows2 ] .)
    RETURN          reduce using rule 44 (matrix2 -> [ rows2 ] .)
    CONTINUE        reduce using rule 44 (matrix2 -> [ rows2 ] .)
    BREAK           reduce using rule 44 (matrix2 -> [ rows2 ] .)
    FOR             reduce using rule 44 (matrix2 -> [ rows2 ] .)
    WHILE           reduce using rule 44 (matrix2 -> [ rows2 ] .)
    IF              reduce using rule 44 (matrix2 -> [ rows2 ] .)
    ID              reduce using rule 44 (matrix2 -> [ rows2 ] .)


state 118

    (46) rows2 -> rows2 , . [ row ]
    [               shift and go to state 140


state 119

    (41) matrix1 -> [ rows1 ] .
    '               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    DOT_DIV         reduce using rule 41 (matrix1 -> [ rows1 ] .)
    /               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    DOT_MUL         reduce using rule 41 (matrix1 -> [ rows1 ] .)
    *               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    DOT_SUB         reduce using rule 41 (matrix1 -> [ rows1 ] .)
    -               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    DOT_ADD         reduce using rule 41 (matrix1 -> [ rows1 ] .)
    +               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    ;               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    ,               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    )               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    LTE             reduce using rule 41 (matrix1 -> [ rows1 ] .)
    GTE             reduce using rule 41 (matrix1 -> [ rows1 ] .)
    NEQ             reduce using rule 41 (matrix1 -> [ rows1 ] .)
    EQ              reduce using rule 41 (matrix1 -> [ rows1 ] .)
    <               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    >               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    :               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    {               reduce using rule 41 (matrix1 -> [ rows1 ] .)
    PRINT           reduce using rule 41 (matrix1 -> [ rows1 ] .)
    RETURN          reduce using rule 41 (matrix1 -> [ rows1 ] .)
    CONTINUE        reduce using rule 41 (matrix1 -> [ rows1 ] .)
    BREAK           reduce using rule 41 (matrix1 -> [ rows1 ] .)
    FOR             reduce using rule 41 (matrix1 -> [ rows1 ] .)
    WHILE           reduce using rule 41 (matrix1 -> [ rows1 ] .)
    IF              reduce using rule 41 (matrix1 -> [ rows1 ] .)
    ID              reduce using rule 41 (matrix1 -> [ rows1 ] .)


state 120

    (43) rows1 -> rows1 ; . row
    (47) row -> . number
    (48) row -> . row , number
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35

    row                            shift and go to state 141
    number                         shift and go to state 87

state 121

    (48) row -> row , . number
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35

    number                         shift and go to state 142

state 122

    (23) for_statement -> FOR variable = expr . : expr block
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    :               shift and go to state 143
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 123

    (22) while_statement -> WHILE ( relative ) . block
    (17) block -> . { lines }
    (18) block -> . line
    (4) line -> . for_statement
    (5) line -> . while_statement
    (6) line -> . if_statement
    (7) line -> . PRINT statement_values ;
    (8) line -> . matrix_assign ;
    (9) line -> . div_assign ;
    (10) line -> . mul_assign ;
    (11) line -> . sub_assign ;
    (12) line -> . add_assign ;
    (13) line -> . RETURN statement_values ;
    (14) line -> . CONTINUE ;
    (15) line -> . BREAK ;
    (16) line -> . assign ;
    (23) for_statement -> . FOR variable = expr : expr block
    (22) while_statement -> . WHILE ( relative ) block
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE block
    (21) if_statement -> . IF ( relative ) block
    (30) matrix_assign -> . ID [ index ] = expr
    (31) matrix_assign -> . ID [ indexes ] = expr
    (29) div_assign -> . variable DIV_ASSIGN expr
    (28) mul_assign -> . variable MUL_ASSIGN expr
    (27) sub_assign -> . variable SUB_ASSIGN expr
    (26) add_assign -> . variable ADD_ASSIGN expr
    (24) assign -> . variable = STRING
    (25) assign -> . variable = expr
    (65) variable -> . ID
    {               shift and go to state 62
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 21

    block                          shift and go to state 144
    line                           shift and go to state 63
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    matrix_assign                  shift and go to state 8
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16
    variable                       shift and go to state 18

state 124

    (72) relative -> expr rel_op . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 145
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 125

    (66) rel_op -> LTE .
    (               reduce using rule 66 (rel_op -> LTE .)
    -               reduce using rule 66 (rel_op -> LTE .)
    ID              reduce using rule 66 (rel_op -> LTE .)
    FLOATNUM        reduce using rule 66 (rel_op -> LTE .)
    INTNUM          reduce using rule 66 (rel_op -> LTE .)
    EYE             reduce using rule 66 (rel_op -> LTE .)
    ONES            reduce using rule 66 (rel_op -> LTE .)
    ZEROS           reduce using rule 66 (rel_op -> LTE .)
    [               reduce using rule 66 (rel_op -> LTE .)


state 126

    (67) rel_op -> GTE .
    (               reduce using rule 67 (rel_op -> GTE .)
    -               reduce using rule 67 (rel_op -> GTE .)
    ID              reduce using rule 67 (rel_op -> GTE .)
    FLOATNUM        reduce using rule 67 (rel_op -> GTE .)
    INTNUM          reduce using rule 67 (rel_op -> GTE .)
    EYE             reduce using rule 67 (rel_op -> GTE .)
    ONES            reduce using rule 67 (rel_op -> GTE .)
    ZEROS           reduce using rule 67 (rel_op -> GTE .)
    [               reduce using rule 67 (rel_op -> GTE .)


state 127

    (68) rel_op -> NEQ .
    (               reduce using rule 68 (rel_op -> NEQ .)
    -               reduce using rule 68 (rel_op -> NEQ .)
    ID              reduce using rule 68 (rel_op -> NEQ .)
    FLOATNUM        reduce using rule 68 (rel_op -> NEQ .)
    INTNUM          reduce using rule 68 (rel_op -> NEQ .)
    EYE             reduce using rule 68 (rel_op -> NEQ .)
    ONES            reduce using rule 68 (rel_op -> NEQ .)
    ZEROS           reduce using rule 68 (rel_op -> NEQ .)
    [               reduce using rule 68 (rel_op -> NEQ .)


state 128

    (69) rel_op -> EQ .
    (               reduce using rule 69 (rel_op -> EQ .)
    -               reduce using rule 69 (rel_op -> EQ .)
    ID              reduce using rule 69 (rel_op -> EQ .)
    FLOATNUM        reduce using rule 69 (rel_op -> EQ .)
    INTNUM          reduce using rule 69 (rel_op -> EQ .)
    EYE             reduce using rule 69 (rel_op -> EQ .)
    ONES            reduce using rule 69 (rel_op -> EQ .)
    ZEROS           reduce using rule 69 (rel_op -> EQ .)
    [               reduce using rule 69 (rel_op -> EQ .)


state 129

    (70) rel_op -> < .
    (               reduce using rule 70 (rel_op -> < .)
    -               reduce using rule 70 (rel_op -> < .)
    ID              reduce using rule 70 (rel_op -> < .)
    FLOATNUM        reduce using rule 70 (rel_op -> < .)
    INTNUM          reduce using rule 70 (rel_op -> < .)
    EYE             reduce using rule 70 (rel_op -> < .)
    ONES            reduce using rule 70 (rel_op -> < .)
    ZEROS           reduce using rule 70 (rel_op -> < .)
    [               reduce using rule 70 (rel_op -> < .)


state 130

    (71) rel_op -> > .
    (               reduce using rule 71 (rel_op -> > .)
    -               reduce using rule 71 (rel_op -> > .)
    ID              reduce using rule 71 (rel_op -> > .)
    FLOATNUM        reduce using rule 71 (rel_op -> > .)
    INTNUM          reduce using rule 71 (rel_op -> > .)
    EYE             reduce using rule 71 (rel_op -> > .)
    ONES            reduce using rule 71 (rel_op -> > .)
    ZEROS           reduce using rule 71 (rel_op -> > .)
    [               reduce using rule 71 (rel_op -> > .)


state 131

    (21) if_statement -> IF ( relative ) . block
    (17) block -> . { lines }
    (18) block -> . line
    (4) line -> . for_statement
    (5) line -> . while_statement
    (6) line -> . if_statement
    (7) line -> . PRINT statement_values ;
    (8) line -> . matrix_assign ;
    (9) line -> . div_assign ;
    (10) line -> . mul_assign ;
    (11) line -> . sub_assign ;
    (12) line -> . add_assign ;
    (13) line -> . RETURN statement_values ;
    (14) line -> . CONTINUE ;
    (15) line -> . BREAK ;
    (16) line -> . assign ;
    (23) for_statement -> . FOR variable = expr : expr block
    (22) while_statement -> . WHILE ( relative ) block
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE block
    (21) if_statement -> . IF ( relative ) block
    (30) matrix_assign -> . ID [ index ] = expr
    (31) matrix_assign -> . ID [ indexes ] = expr
    (29) div_assign -> . variable DIV_ASSIGN expr
    (28) mul_assign -> . variable MUL_ASSIGN expr
    (27) sub_assign -> . variable SUB_ASSIGN expr
    (26) add_assign -> . variable ADD_ASSIGN expr
    (24) assign -> . variable = STRING
    (25) assign -> . variable = expr
    (65) variable -> . ID
    {               shift and go to state 62
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 21

    block                          shift and go to state 146
    line                           shift and go to state 63
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    matrix_assign                  shift and go to state 8
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16
    variable                       shift and go to state 18

state 132

    (30) matrix_assign -> ID [ index ] . = expr
    =               shift and go to state 147


state 133

    (31) matrix_assign -> ID [ indexes ] . = expr
    =               shift and go to state 148


state 134

    (39) indexes -> INTNUM , . INTNUM
    INTNUM          shift and go to state 149


state 135

    (17) block -> { lines } .
    ELSE            reduce using rule 17 (block -> { lines } .)
    PRINT           reduce using rule 17 (block -> { lines } .)
    RETURN          reduce using rule 17 (block -> { lines } .)
    CONTINUE        reduce using rule 17 (block -> { lines } .)
    BREAK           reduce using rule 17 (block -> { lines } .)
    FOR             reduce using rule 17 (block -> { lines } .)
    WHILE           reduce using rule 17 (block -> { lines } .)
    IF              reduce using rule 17 (block -> { lines } .)
    ID              reduce using rule 17 (block -> { lines } .)
    $end            reduce using rule 17 (block -> { lines } .)
    }               reduce using rule 17 (block -> { lines } .)


state 136

    (32) matrix -> EYE ( INTNUM ) .
    '               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    DOT_DIV         reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    /               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    DOT_MUL         reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    *               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    DOT_SUB         reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    -               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    DOT_ADD         reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    +               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    ;               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    ,               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    )               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    LTE             reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    GTE             reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    NEQ             reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    EQ              reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    <               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    >               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    :               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    {               reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    PRINT           reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    RETURN          reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    CONTINUE        reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    BREAK           reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    FOR             reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    WHILE           reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    IF              reduce using rule 32 (matrix -> EYE ( INTNUM ) .)
    ID              reduce using rule 32 (matrix -> EYE ( INTNUM ) .)


state 137

    (33) matrix -> ONES ( INTNUM ) .
    '               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    DOT_DIV         reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    /               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    DOT_MUL         reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    *               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    DOT_SUB         reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    -               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    DOT_ADD         reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    +               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    ;               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    ,               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    )               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    LTE             reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    GTE             reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    NEQ             reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    EQ              reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    <               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    >               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    :               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    {               reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    PRINT           reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    RETURN          reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    CONTINUE        reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    BREAK           reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    FOR             reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    WHILE           reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    IF              reduce using rule 33 (matrix -> ONES ( INTNUM ) .)
    ID              reduce using rule 33 (matrix -> ONES ( INTNUM ) .)


state 138

    (34) matrix -> ZEROS ( INTNUM ) .
    '               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    DOT_DIV         reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    /               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    DOT_MUL         reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    *               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    DOT_SUB         reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    -               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    DOT_ADD         reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    +               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    ;               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    ,               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    )               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    LTE             reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    GTE             reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    NEQ             reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    EQ              reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    <               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    >               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    :               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    {               reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    PRINT           reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    RETURN          reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    CONTINUE        reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    BREAK           reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    FOR             reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    WHILE           reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    IF              reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)
    ID              reduce using rule 34 (matrix -> ZEROS ( INTNUM ) .)


state 139

    (45) rows2 -> [ row ] .
    ]               reduce using rule 45 (rows2 -> [ row ] .)
    ,               reduce using rule 45 (rows2 -> [ row ] .)


state 140

    (46) rows2 -> rows2 , [ . row ]
    (47) row -> . number
    (48) row -> . row , number
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35

    row                            shift and go to state 150
    number                         shift and go to state 87

state 141

    (43) rows1 -> rows1 ; row .
    (48) row -> row . , number
    ]               reduce using rule 43 (rows1 -> rows1 ; row .)
    ;               reduce using rule 43 (rows1 -> rows1 ; row .)
    ,               shift and go to state 121


state 142

    (48) row -> row , number .
    ,               reduce using rule 48 (row -> row , number .)
    ]               reduce using rule 48 (row -> row , number .)
    ;               reduce using rule 48 (row -> row , number .)


state 143

    (23) for_statement -> FOR variable = expr : . expr block
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    variable                       shift and go to state 77
    expr                           shift and go to state 151
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 144

    (22) while_statement -> WHILE ( relative ) block .
    PRINT           reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    RETURN          reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    CONTINUE        reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    BREAK           reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    FOR             reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    WHILE           reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    IF              reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    ID              reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    $end            reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    ELSE            reduce using rule 22 (while_statement -> WHILE ( relative ) block .)
    }               reduce using rule 22 (while_statement -> WHILE ( relative ) block .)


state 145

    (72) relative -> expr rel_op expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    )               reduce using rule 72 (relative -> expr rel_op expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 146

    (21) if_statement -> IF ( relative ) block .
    ELSE            reduce using rule 21 (if_statement -> IF ( relative ) block .)
    PRINT           reduce using rule 21 (if_statement -> IF ( relative ) block .)
    RETURN          reduce using rule 21 (if_statement -> IF ( relative ) block .)
    CONTINUE        reduce using rule 21 (if_statement -> IF ( relative ) block .)
    BREAK           reduce using rule 21 (if_statement -> IF ( relative ) block .)
    FOR             reduce using rule 21 (if_statement -> IF ( relative ) block .)
    WHILE           reduce using rule 21 (if_statement -> IF ( relative ) block .)
    IF              reduce using rule 21 (if_statement -> IF ( relative ) block .)
    ID              reduce using rule 21 (if_statement -> IF ( relative ) block .)
    $end            reduce using rule 21 (if_statement -> IF ( relative ) block .)
    }               reduce using rule 21 (if_statement -> IF ( relative ) block .)


state 147

    (30) matrix_assign -> ID [ index ] = . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 152
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 148

    (31) matrix_assign -> ID [ indexes ] = . expr
    (51) expr -> . variable
    (52) expr -> . variable '
    (53) expr -> . number
    (54) expr -> . matrix
    (55) expr -> . ( expr )
    (56) expr -> . expr DOT_DIV expr
    (57) expr -> . expr / expr
    (58) expr -> . expr DOT_MUL expr
    (59) expr -> . expr * expr
    (60) expr -> . expr DOT_SUB expr
    (61) expr -> . expr - expr
    (62) expr -> . expr DOT_ADD expr
    (63) expr -> . expr + expr
    (64) expr -> . - expr
    (65) variable -> . ID
    (49) number -> . FLOATNUM
    (50) number -> . INTNUM
    (32) matrix -> . EYE ( INTNUM )
    (33) matrix -> . ONES ( INTNUM )
    (34) matrix -> . ZEROS ( INTNUM )
    (35) matrix -> . matrix2
    (36) matrix -> . matrix1
    (37) matrix -> . [ ]
    (38) matrix -> . matrix '
    (44) matrix2 -> . [ rows2 ]
    (41) matrix1 -> . [ rows1 ]
    (               shift and go to state 32
    -               shift and go to state 33
    ID              shift and go to state 29
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    EYE             shift and go to state 36
    ONES            shift and go to state 37
    ZEROS           shift and go to state 38
    [               shift and go to state 41

    expr                           shift and go to state 153
    variable                       shift and go to state 77
    number                         shift and go to state 30
    matrix                         shift and go to state 31
    matrix2                        shift and go to state 39
    matrix1                        shift and go to state 40

state 149

    (39) indexes -> INTNUM , INTNUM .
    ]               reduce using rule 39 (indexes -> INTNUM , INTNUM .)


state 150

    (46) rows2 -> rows2 , [ row . ]
    (48) row -> row . , number
    ]               shift and go to state 154
    ,               shift and go to state 121


state 151

    (23) for_statement -> FOR variable = expr : expr . block
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    (17) block -> . { lines }
    (18) block -> . line
    (4) line -> . for_statement
    (5) line -> . while_statement
    (6) line -> . if_statement
    (7) line -> . PRINT statement_values ;
    (8) line -> . matrix_assign ;
    (9) line -> . div_assign ;
    (10) line -> . mul_assign ;
    (11) line -> . sub_assign ;
    (12) line -> . add_assign ;
    (13) line -> . RETURN statement_values ;
    (14) line -> . CONTINUE ;
    (15) line -> . BREAK ;
    (16) line -> . assign ;
    (23) for_statement -> . FOR variable = expr : expr block
    (22) while_statement -> . WHILE ( relative ) block
    (19) if_statement -> . if_statement ELSE if_statement
    (20) if_statement -> . if_statement ELSE block
    (21) if_statement -> . IF ( relative ) block
    (30) matrix_assign -> . ID [ index ] = expr
    (31) matrix_assign -> . ID [ indexes ] = expr
    (29) div_assign -> . variable DIV_ASSIGN expr
    (28) mul_assign -> . variable MUL_ASSIGN expr
    (27) sub_assign -> . variable SUB_ASSIGN expr
    (26) add_assign -> . variable ADD_ASSIGN expr
    (24) assign -> . variable = STRING
    (25) assign -> . variable = expr
    (65) variable -> . ID
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74
    {               shift and go to state 62
    PRINT           shift and go to state 7
    RETURN          shift and go to state 13
    CONTINUE        shift and go to state 14
    BREAK           shift and go to state 15
    FOR             shift and go to state 17
    WHILE           shift and go to state 19
    IF              shift and go to state 20
    ID              shift and go to state 21

    variable                       shift and go to state 18
    block                          shift and go to state 155
    line                           shift and go to state 63
    for_statement                  shift and go to state 4
    while_statement                shift and go to state 5
    if_statement                   shift and go to state 6
    matrix_assign                  shift and go to state 8
    div_assign                     shift and go to state 9
    mul_assign                     shift and go to state 10
    sub_assign                     shift and go to state 11
    add_assign                     shift and go to state 12
    assign                         shift and go to state 16

state 152

    (30) matrix_assign -> ID [ index ] = expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    ;               reduce using rule 30 (matrix_assign -> ID [ index ] = expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 153

    (31) matrix_assign -> ID [ indexes ] = expr .
    (56) expr -> expr . DOT_DIV expr
    (57) expr -> expr . / expr
    (58) expr -> expr . DOT_MUL expr
    (59) expr -> expr . * expr
    (60) expr -> expr . DOT_SUB expr
    (61) expr -> expr . - expr
    (62) expr -> expr . DOT_ADD expr
    (63) expr -> expr . + expr
    ;               reduce using rule 31 (matrix_assign -> ID [ indexes ] = expr .)
    DOT_DIV         shift and go to state 67
    /               shift and go to state 68
    DOT_MUL         shift and go to state 69
    *               shift and go to state 70
    DOT_SUB         shift and go to state 71
    -               shift and go to state 72
    DOT_ADD         shift and go to state 73
    +               shift and go to state 74


state 154

    (46) rows2 -> rows2 , [ row ] .
    ]               reduce using rule 46 (rows2 -> rows2 , [ row ] .)
    ,               reduce using rule 46 (rows2 -> rows2 , [ row ] .)


state 155

    (23) for_statement -> FOR variable = expr : expr block .
    PRINT           reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    RETURN          reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    CONTINUE        reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    BREAK           reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    FOR             reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    WHILE           reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    IF              reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    ID              reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    $end            reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    ELSE            reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)
    }               reduce using rule 23 (for_statement -> FOR variable = expr : expr block .)


Conflicts:

shift/reduce conflict for ELSE in state 6 resolved as shift
shift/reduce conflict for ELSE in state 60 resolved as shift
reduce/reduce conflict in state 26 resolved using rule expr -> variable
rejected rule (statement_value -> variable) in state 26
reduce/reduce conflict in state 60 resolved using rule line -> if_statement
rejected rule (if_statement -> if_statement ELSE if_statement  [precedence=right, level=1]) in state 60
Rule (statement_value -> variable) is never reduced
Rule (if_statement -> if_statement ELSE if_statement  [precedence=right, level=1]) is never reduced